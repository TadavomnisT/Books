<!DOCTYPE HTML><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><title>RAM vs HDD</title> <link href="https://tadavomnist.github.io/assets/css/highlightjs.default.min.css" rel="stylesheet"/><style type="text/css">*,pre code,table,table tr{padding:0}hr,html{overflow:hidden}*{box-sizing:border-box;outline:0;margin:0}body,html{position:relative;width:100vw;height:100vh}html{color-scheme:light}body{padding:10px 15px;overflow:hidden auto;overflow-wrap:break-word;word-wrap:break-word;font:16px/1.4 Helvetica,Arial,sans-serif;color:#333}body,html,table tr{background-color:#fff}.highlight pre,code,pre,tt{background-color:#f8f8f8;direction:ltr!important}table tr :is(th,td){border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{position:relative;box-sizing:content-box;font-weight:700;padding:15px 0;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;border:0;border-bottom:1px solid #ddd}a{color:#4183c4}a.absent{color:#c00}ol,ul{padding-left:15px;margin:0 7px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr :is(th,td) :first-child{margin-top:0}table tr :is(th,td) :last-child{margin-bottom:0}img{max-width:100%;pointer-events:none}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;overflow-wrap:break-word;border:1px solid #eaeaea;border-radius:3px}tt{white-space:nowrap}pre code{white-space:pre;border:none}.highlight pre,pre{border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;margin:.8em 0 1em;border-radius:3px;max-width:calc(100% - 2px)}#container{width:960px;margin: 0 auto;}.dark-mode{background-color:#000;color:#fff;}.dark-mode code{background-color:#212121;color:rgb(0,183,255);}.dark-mode pre{background-color:#433f3f !important;}*,*:before,*:after{box-sizing:border-box;}.toggle{cursor:pointer;display:inline-block;}.toggle-switch{display:inline-block;background:#ccc;border-radius:16px;width:58px;height:32px;position:relative;vertical-align:middle;transition:background 0.25s;}.toggle-switch:before,.toggle-switch:after{content:"";}.toggle-switch:before{display:block;background:linear-gradient(to bottom,#fff 0%,#eee 100%);border-radius:50%;box-shadow:0 0 0 1px rgba(0,0,0,0.25);width:24px;height:24px;position:absolute;top:4px;left:4px;transition:left 0.25s;}.toggle:hover .toggle-switch:before{background:linear-gradient(to bottom,#fff 0%,#fff 100%);box-shadow:0 0 0 1px rgba(0,0,0,0.5);}.toggle-checkbox:checked + .toggle-switch{background:#3e96df;}.toggle-checkbox:checked + .toggle-switch:before{left:30px;}.toggle-checkbox{position:absolute;visibility:hidden;}.toggle-label{margin-left:5px;position:relative;top:2px;}</style></head><body><div id="container"><div id="container"><label class="toggle"><input class="toggle-checkbox" type="checkbox" checked="checked" id="dark-mode-toggle"><div class="toggle-switch"></div><span class="toggle-label">Dark mode</span></label><h1>مقایسه سرعت خوندن/نوشتن RAM و HDD</h1>
<h2>چکیده</h2>
<p>توی این مقاله به تفصیل راجع به سرعت خوندن/نوشتن اطلاعات روی رم و روی هارددیسک صحبت میکنم، برای این منظور ابتدا تکنولوژی زیر باک رم و زیر باک هارددیسک رو توضیح میدم، بعدش به این موضوع میپردازم که بخاطر پیچیدگی های تکنولوژیک، متوسط سرعت خوندن/نوشتن توی هر کدوم چقدره و با هم مقایسه‌شون میکنم.</p>
<h2>چرا میخوایم سرعت رم و هارد دیسک رو مقایسه کنیم؟</h2>
<p>RAM vs HDD</p>
<p>چند سال پیش توی یه فرومی توی یه تایپیکی مربوط به برنامه‌نویسی من به این نکته اشاره کردم که سرعت خوندن/نوشتن توی هارددیسک بطور متوسط 100 هزار بار از رم کمتره..!
برای بسیاری از برنامه‌نویسها این حرف عجیب بود، و خیلیا قبولش نمیکردن، برای همین من مجبور شدم تکنولوژی هر دو رو توضیح بدم و با زبان تخصصی بگم که چرا چنین حرفی زدم.
با این مقاله همراه باشین تا ببینیم چرا میگم هارد دیسک بطور متوسط صد هزار بار از رم کند تره.</p>
<p>اولا که واضحه هیچوقت نمیتونیم همچین چیزیو بطور دقیق بگیم، هر کسی ادعا کنه که مثلاً HDD دقیق انقدر از RAM سریع تره ، معلومه که خیلی چیزارو نمیدونه.</p>
<p>دوما ، مقایسه هارد دیسک و رم عمرا توی یک مقاله بگنجه:)
من میتونم یک کتاب چند جلدی راجع به RAM بنویسم و یک کتاب چند جلدی راجع به HDD و توی یک کتاب چند جلدی اینارو با هم مقایسه کنم! نه بخاطر اینکه من خیلی عالم هستم ، بلکه بخاط اینکه متوجه بشین حجم و عمق مطلب خیلی زیاده .
اینجوری نیست که ما بگیم آره سرعت این موجودیت رو توی اینترنت نوشته انقدر و سرعت اونو نوشته فلانقدر و بقیه‌ش یه تقسیم ساده‌ست، .....</p>
<p>بلکه این مطلب میتونه بعنوان تز دکتری توی تحصیلات عالیه مطرح بشه، و یک نفر پایانامه دکتراشو صرف این کنه و یه مقاله بنویسه، که بازم نمیتونه کل مطلب رو ادا کنه..</p>
<p>اینارو صرفا عرض کردم که بدونین چقدر ماجرای عمیقیه...😬❤️
بیشتر مطالبی که راجع به هارددیسک بیان میکنم رو من چندین سال قبل از کتاب استاد آبراهام سیلورچتس خونده بودم. اسم کتاب هست:</p>
<ul>
<li>Database System Concepts, 6th Edition</li>
</ul>
<h2>رم چیست؟</h2>
<p>رم – RAM – مخفف Random Access Memory هست یعنی حافظه ای با دسترسی تصادفی، خود این اسم تمام ساختاری که لازم هست راجع به رم بدونیم رو توضیح میده. فرض کنید یه تیکه حافظه گنده دارید که سرعتش نسبتا بالاست (نسبت به تکنولوژیهایی مثل دیسک و ای2پیرام) و شمای انتزاعیش همچین چیزیه:</p>
<p><img src="Files/1.png" alt="Abstract RAM schema" /></p>
<p><em>مدل انتزاعی یک رم</em></p>
<p>هر خونه‌ش رو یک بایت فرض کنید، n تا بایت پشت سر هم که میتونید با سرعت نسبتاً بالا توش اطلاعات رو ذخیره کنید. این سرعت بالا به سیستم عامل این امکان رو میده که جایی داشته باشه که با سرعتی معقول اطلاعات محاسبات فعلیش رو ذخیره سازی کنه.</p>
<p>اما چرا سرعتش بالاست؟</p>
<p>از لحاظ پیاده‌سازی سخت افزاری، این حافظه روی یه آرایه دو بعدی مدل شده،‌ مثل یه ماتریس. ساختار «Random Access» این امکان رو ایجاد میکنه که ما به تمام خونه های مختلف حافظه در یک زمان یکسان دسترسی داشته باشیم، اما چطور؟
بیاین ساختار بلوک منطقی رم رو نگاه کنیم:</p>
<p><img src="Files/2.png" alt="RAM Logical structure" /></p>
<p><em>یک رم 8 بیتی - منبع عکس <a href="https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm">ETSU</a></em></p>
<p>امروزه رم ها از خونه‌های کوشولویی که توی یه آرایه دو بعدی هستن تشکیل شدن. هر رم یک واحد Address-Decoder داره که آدرسی انکد شده در مبنای 2 (باینری) رو دریافت میکنه و اون رو دیکد میکنه که ببینه کدوم سلول حافظه باید انتخاب بشه (برای خوندن/نوشتن).
توی همین عکس یه واحد منطقی Read/Write داریم که کارش اینه که خبر بده آیا باید چیزی نوشته بشه یا باید چیزی خونده بشه.
همچنین یه واحد دیگه هم وجود داره به اسم Cheap-Select ، این برای موقعی هست که ما بیش از یک چیپ مموری داریم (در واقعیت اینجوریه).
همچنین ساختاری به نام databus وجود داره که توش 0 با ولتاژ پایین و 1 با ولتاژ بالا نشون داده میشه، این قسمت ورودی/خروجی سلول‌های چیپ رم هست.
همچنین فرض کنید سطرهای رم 8 بیتی یا 1 بایتی هستن.</p>
<p>فرض کنید شما میخواین توی خونه هزارم (1000) رم بنویسین، برای این حداقل یک آدرس دیکودر 10 بیتی لازم دارین ( چون 2 به توان 10 میشه 1024 و با یک آدرس دیکودر 10 بیتی میشه بین 1024 تا خونه رم تمییز قائل شد و آدرسدهی کرد). حالا شما 1000 در مبنای 10 رو میبرید به مبنای 2 که میشه : 1111101000 
و این عدد آدرس باینری 1111101000 رو میفرستید به آدرس-دیکودر. آدرس-دیکودر با گیتهای منطقی درونی که داره، با گرفتن  1111101000 به عنوان ورودی، سطر هزارم رم رو انتخاب (select) میکنه و خوندن/نوشتن اتفاق می‌افته.
دقیقاً فرقش با یه تکنلوژی مثل دیسک همینه...، توی دیسک باید یکسری خونه پیمایش بشن تا برسیم به خونه مد نظر، اما اینجا یه مدار منطقی داریم که آدرس-دیکودر مدار خاصیش رو روشن میکنه. صرفاً اون مدار انتخاب میشه و نه تنها حرکت فیزیکی نداریم (در مقایسه با دیسک) بلکه پیمایش خونه به خونه هم نداریم (در مقایسه با دیگر تکنولوژیها) 
یک آدرس-دیکودر 3 بیتی توی شکل زیر نشون داده شده، حتماً در جریانید که با 3 بیت میشه 2 به توان 3 یعنی 8 حالت مختلف داشته باشیم. پس یه آدرس دیکودر 3 بیتی میتونه 8 خونه از رم رو آدرسدهی کنه و همرو با یک سرعت یکسان انتخاب کنه.</p>
<p><img src="Files/3.png" alt="3-bit Address-Decoder" /></p>
<p><em>یک آدرس دیکودر 3بیتی با 8 پایانه- منبع عکس <a href="https://codestall.wordpress.com/2017/09/02/532-decoder-design-using-4-38-decoders-and-1-24-decoder-in-verilog/">Codestall</a></em></p>
<p>یک آدرس-دیکودر 10 بیتی هم عین همین ساخته میشه، و میتونه 1024 تا سطر مختلف رو انتخاب کنه، فقط شکلش توی این مقاله جا نمیشه:))</p>
<p>پس این شد معنی ساختار «دسترسی تصادفی» یا «Random Access»، یعنی زمانی که ما یک طراحی سخت‌افزاری داریم که اوردر زمانی دسترسی به هر سلول حافظه ما با بقیه سلولها برابره، این اتفاق با پیاده‌سازی یه گیت منطقی ممکن میشه که بهش میگیم آدرس-دیکودر و توضیحش دادیم.</p>
<p>اگر سرعت دسترسی اینقدر عالی و خوبه، چرا ما RAM رو جایگذین یچیزی مثل دیسک نمیکنیم و ازش استفاده نمیکنیم؟
رم بخاطر ساختار منطقی و الکترونیکی که داره، با قطع شدن جریان برق، تمام اطلاعات داخلش پاک میشه و اصطلاحاً تمام اطلاعاتش ریست میشه(بیتهاش 0 میشه).
این در مقابل دیسک، نمیتونه یه حافظه استیبل برای ذخیره سازی طولانی مدت باشه...، صرفاً برای ذخیره اطلاعات فعلی محدود به محاسبات کامپیوتر خوبه.</p>
<p>این روزها حافظه هایی مثل SSD که حرکت فیزیکی ندارن دارن به جای چیزهایی مثل HDD در بعضی جاها استفاده میشن – اونا بخاطر نداشتن حرکت فیزیکی بسیار سریع ترن – اما مشکلات خودشونم دارن. شاید در آینده توی یه مقاله جدا اون تکنولوژیهارو هم بررسی کردیم.</p>
<p>برگردیم به رم، از لحاظ تکنولوژی ساخت رم ها به دو دسته استاتیک و داینامیک تقسیم میشن.</p>
<ul>
<li>رمهای استاتیک (SRAM):</li>
</ul>
<p>رمهای استاتیک اطلاعات رو توی مدارهای ترانزیستوری شبیه D-فلیپ فلاپ ذخیره میکنن، و این اطلاعات مادامی که رم برق داشته باشه اونجا میمونن و از بین نخواهند رفت. نسبت به رم های داینامیک کوشولوتر هستن و سرعتشون بیشتره و دیکودر ساده‌تری دارن. معمولاً توی فرایندهای سرعتی مثل کش کردن و اپلیکیشنهای خیلی سریع استفاده میشن.
بعضی جاها که میخوان اطلاعات مهم رو روی رم نگه دارن، از همین SRAM استفاده میکنن و یه باتری بک‌آپ به مدار اضافه میکنن که حتی اگه به هر دلیلی برق مدار قطع شد، باتری سیستم رو تغذیه کنه و اطلاعات پاک نشه.</p>
<ul>
<li>رمهای داینامیک (DRAM):</li>
</ul>
<p>رمهای داینامیک اطلاعات رو رو خازنها ذخیره میکنن. این خازنها بخاطر ساختار کوشولوتری که دارن ظرفیت کلی رم رو میرن بالا، اما این خازنها یه مشکل بزرگ دارن، هر خازن طبق طبیعت الکترونیکش بعد از مدت زمانی جریان داخلی خودش رو از دست میده و اصطلاحاً دِشارژ میشه. بعد از  دِشارژ شدن یه خازن اطلاعاتی هم که توش ذخیره شده بوده میپره! به این روند میگن leak شدن جریان برق. برای جلوگیری از - از دست رفتن اطلاعات، باید تند-تند اطاعات کل خازنها خونده بشن و دوباره همونجا نوشته بشن که خازنها شارژ بمونن و اطلاعات از دست نره. به این روند میگن refresh کردن مدار. پس توی DRAM ها باید یه مدار ریفرش-کننده باشه که اطلاعات همه خازنهارو هی تند-تند بخونه و هی تند-تند دوباره سر جاشون بنویسه.
ضمناً رمهای داینامیک خیلی از رمهای اساتیک ارزونتر هستن، و رمهایی که روی سیستم شما الان دارن استفاده میشن احتمالاً دینامیک هستن.</p>
<p>بهتون پیشنهاد میکنم مصاحبه استیو ووزنیاک رو حتماً مطالعه کنین، این مصاحبه علیرغم اینکه قرار بوده مصاحبه محاوره ای و معمولی نسبت به خودش شخص ووز باشه، توش بینهایت توضیحات تخصصی الکترونیکی داره..!
یه قسمتش راجع به تکنولوژی رمها حرف میزنه که خیلی جالبه:</p>
<p><em>«...به اطرافم نگاه کردم، اولین رم دینامیک همون سال معرفی شده بود. 1975 اولین رم دینامیک 4کلیوبایتی به بازار اومده بود. این اولین بار بود که قیمت رم از قیمت حافظه‌های مغناطیسی، که تا امروز در همه جا استفاده میشد کمتر بود. حالا ناگهان دنیا داشت به سمت رم میرفت، حافظه ما از این به بعد روی سیلیکون بود. تقریبا همه در جهان، آلتیر – شفر کامپیوتر – پلیمرفیک کامپیوتر – اینسایت کامپیوتر و ...، با مهندسهایی ناکارآمد و نه بهترین مهندس های موجود طراحی میکردن. اونها تکنسینهایی بودن که میدونستن باید چطور دیتاشیت رمهارو بخونن و بعد توی دیتاشیت ریزپردازنده‌ها دنبال خطی بگردن که توش نوشته شده آدرس، و اونو با آدرس رم تطبیق بدن و سیمکشی کنن. این کار ساده ایه، اما فقط در صورتی کار میکنه که رمهای شما استاتیک باشن. رمهای دینامیک قیمتی برابر نصف یا حتی یک چهارم قبلیا داشتن. معنی رم دینامیک این بود که به جای داشتن 32 تراشه برای ساخت کامپیوتری که زبون بفهمه، میتونستین 8 تراشه رم داشته باشین. اما رم دینامیک به مدارهایی نیاز داشت که در هر ثانیه 2000 بار به تک تک آدرسهاشون سر بزنن و چیزی که اونجاست رو بخونن و دوباره اونارو همونجا بنویسن تا اطلاعات از دست نره! رم دینامیک که امروز هم در کامپیوتر ما وجود داره هر بیتی رو فقط در دوهزارم ثانیه فراموش میکنه مگر اینکه یه نفر اون بیت رو توی این زمان بخونه و دوباره سر جاش بنویسه. میشه اینطور گفت که الکترون ها توی بشقابین که در هر 2هزارم ثانیه ازش میریزن بیرون..!»</em></p>
<p>ترجمه از استاد جادی، کل مصاحبه به زبان فارسی:
<a href="https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90">https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90</a></p>
<p>اصل مصاحبه:
<a href="http://www.foundersatwork.com/steve-wozniak.html">http://www.foundersatwork.com/steve-wozniak.html</a></p>
<p>و دیگه تقریباً تمام مسائل تکنیکی که میخواستم راجع به رمها بگم رو گفتم، مدیریت یک رم بر عهده سیستم عامله. CPU کامپیوتر با Virtual-Addressing کار میکنه و خود رم با Logical-Addressing. 
بعداً یه مقاله جدا راجع به اینکه سیستم عامل چه‌جوری رم رو به پراسسها تخصیص میده مینویسم و یه مقاله جدا هم مینویسم راجع به اینکه چطور میتونیم به کل رم فعلی سیستم دسترسی داشته باشیم.</p>
<h2>هارددیسک چیست؟</h2>
<p>دیسکها، لوحهای گرد و دایره‌ای شکلی هستن که میتونن بسته به معماریشون اطلاعات رو توی خودشون ذخیره کنن، اولین نوع دیسکهارو میتونیم توی گرامافونها ببینیم، که اونجا صدای ورودی به گرامافون باعث ایجاد لرزه میشد و سوزن روی لوح گردی که میچرخید یه شیاری رو بصورت حلزونی ایجاد میکرد. برای پخش صدا سوزن نرم تری میذاشتن که توی شیار حرکت میکرد و با استفاده از لرزش صدارو بازپخش میکرد.
بعدها دیسکهای سخت مغناطیسی اومدن که ازشون میخوایم حرف بزنیم و همینطور دیسکهای نوری مثل CD ها و DVDهارو داشتیم که با یک لیزر توشون اطلاعات burn میشد.
پس دیسک به طور کلی توی این حوزه،‌معمولا لوح گردی هست که حول یه محوی میچرخه و اطلاعات توی شعاع های مختلف اون نوشته میشه.</p>
<p>یه هارددیسک، شامل دیسکهای گرد مغناطیسی هست که اطلاعات توش با مغناطیسه شدن هر ذره کوشولو از دیسک، بصورت باینری نوشته میشه. هارددیسک معمولا از چند تا لایه (پلاتر-platter) تشکیل شده، تعداد این پلاتر ها معمولا بین 1 تا 5 تا هست.
اگه بصورت یه برش عرضی ببینیم این شکلی میشه:</p>
<p><img src="Files/4.jpg" alt="HDD Platters" /></p>
<p><em>منبع عکس <a href="https://www.compuclever.com/posts/hard-disk-drive-basics/ic306536/">compuclever</a></em></p>
<p>همون برش عرضی بصورت انتزاعی:</p>
<p><img src="Files/5.jpg" alt="HDD Abstract Platters" /></p>
<p><em>منبع عکس: کتاب Database System Concepts, 6th Edition</em></p>
<p>حالا این پلاتر ها، یه سطح مغناطیسی هستن که میتونن با مغناطیسه شدن، 0 و 1 هارو توی خودشون ذخیره کنن.
این پلاتر، به شکل منطقی (logical) به یسری شعاع های متفاوت تقسیم میشه، که این شعاعها شامل دایره‌های گردی هستن که دیسک رو میسازن، به هر کدوم از این شعاع ها میگن یه ترک- Track
توی عکس زیر چندین ترک انتزاعی رو میبینید:</p>
<p><img src="Files/6.jpg" alt="HDD Tracks" /></p>
<p><em>منبع عکس <a href="https://www.schoolcoders.com/memory-storage/secondary-storage/hdd/">schoolcoders</a></em></p>
<p>خود این ترک به قسمتهای کوچکتری تقسیم میشه، که بهش میگن سکتور- sector
توی عکس زیر قسمت سکتور رو مشاهده میکنید:</p>
<p><img src="Files/7.jpg" alt="HDD Sectors" /></p>
<p><em>منبع عکس <a href="https://slideplayer.com/slide/1517076/">slideplayer</a></em></p>
<p>یه سکتور کوچکترین واحدی توی دیسک هست که نوشته/خونده میشه، معمولا سایز یه سکتور 512 بایت هست...</p>
<p>یه دسته‌ای هم توی یه هارددیسک وجود داره که بهش میگن arm که سرش یه هد (head) داره که عقب جلو میره و خود دسته هه هم میچرخه و این سکتورهارو میخونه یا توشن مینویسه.</p>
<p>منطقا ترکهای بیرونی(شعاع های بزرگتر) تعداد سکتورهای بیشتری از ترکهای درونی(شعاعهای کویچکتر) دارن..</p>
<p>هر نوع اطلاعاتی که بخواد روی دیسک نوشته بشه، باید بصورت 0 و 1 نوشته بشه، یعنی بصورت باینری انکد بشه، و به آرم  داده بشه که توسط هد توش نوشته بشه. همین داستان برای خوندن هم بر قراره.
بسته به فرمتهای مختلف نرم افزاری که هارددیسکهارو با اونها فرمت میکنیم، یکسری تکنولوژی نرم‌افزاری وجود دارن که مربوط به بحث ذخیره سازی داده‌ها هستن مثل inode و mft که بعداً توی مقالات دیگه راجع بهشون حرف میزنیم.</p>
<h2>مقایسه سرعت هارددیسک و رم</h2>
<p>فرض کنید تمام پیچیدگی های پیاده سازی و عملیاتی و سیستم عاملی رم رو نادیده بگیریم ، و یه راست بریم سراغ هارد دیسک:</p>
<p>وقتی سرعت یک هارد دیسک رو میخوایم در نظر بگیریم ، باید سرعت متوسط اعمال I/O رو توی اون در نظر بگیریم یعنی ورودی خروجی های هارد دیسک
*Input/Output
یا به زبان فارسی ساده : خوندنها و نوشتن‌ها</p>
<p>محاسبه این سرعت بشدت کار تخصصی هست و توی این سرعت هزاران فاکتور دخیله، فاکتور هایی که هر کدوم توضیح دادنشون یک کتابه مطلبه و نهایتا اگر تمام فاکتور هارو بتونیم مدلسازی کنیم ، (که خیلی کار سختیه) در سناریو های مختلف ممکنه از 10 هزاربار تا مثلا 500 هزار بار کند تر عمل کنه. که متوسط این سناریو هارو بعنوان آمار بیان میکنن.</p>
<p>یک هارد دیسک ، مثل یک CD یه (چند تا) دیسک داره که میچرخه و یک هد داره (مثل اون دسته سیاهای توی گرامافون) که روی یه مداری که روی شعاع دیسک واقع شده میتونه بالا و پایین بره. به این ترتیب میتونه تمام دیسک رو پردازش کنه.</p>
<p>گیف پایین رو مشاهده بفرمائید:</p>
<p><img src="Files/8.gif" alt="HDD head move" /></p>
<p><em>یادم نمیاد منبع گیف کجاست- اگر میدونید خبر بدین!</em></p>
<hr />
<p>یک سرعتی برای هارد دیسک بیان میشه بعنوان Transfer time که مجموعه کلی‌ای از چند تا سرعت هست وابسته به فاکتور های زیر :</p>
<p>1 - سرعت خوندن هد {سرعت خوندن دیتا توسط هد ، باز خودش وابسته هست به 7-8 تا فاکتور! ما میگیم که متفاوته و ریزتر نمیشیم}</p>
<p>2 - سرعت بالا و پایین شدن هد</p>
<p>3 - سرعت چرخش دیسک {در هارد دیسکهای متفاوت‌، این سرعت متفاوت هست}</p>
<p>4 - ظرفیت ترک (track)</p>
<p>5 - ظرفیت سکتور</p>
<p>6 - مقدار دیتای طلب شده</p>
<p>7 - تاخیر چرخشی (این با سرعت چرخش فرفق میکنه ) بهش میگن Rotational Latency
(من یکمی توی همین مقاله توضیحش میدم ولی خیلی بیشتر از این مطلب لازم داره، توی کتابی که معرفی کردم خیلی خوب توضیح داده)</p>
<p>8 - تاخیر seek کردن هد یا seek time
( اینم جلوتر من یکمی توضیحش میدم )</p>
<p>9 - بلاک اینترلیود بودن هارد دیسک (اینو بعدش توضیح میدم و میگم که چه فرقی با رم داره که رم بایت اینترلیود هست - این خیلی جالبه) </p>
<p>10 - تکنیک جلو-جلو خوندن هارددیسک یا read ahead 
(اینم باید توضیح بدم)</p>
<p>11 - ظرفیت اتخاذ شده برای تکنیک بافرینگ Buffering. 
(اینم باید توضیح بدم)</p>
<p>12 - الگوریتمهای زمانبندی روی هارد دیسک! این مطلب خودش میتونه یه کتاب 12 جلدی باشه! من واقعا نمیدونم چجوری میتونم حق مطلب رو توی این مقاله ساده بیان کنم! زبان من الکن هست از توصیفش - مثلا من اگه میشد الگوریتم آسانسورو برای شما شرح بدم که ببینین اگر نبود هارددیسک یک ملیارد بار کند تر میشد...!</p>
<p>13 - نحوه چینش فایلها!!! این دیگه واقعا خیلی خییلی خیلی خیلی توضیح میطلبه!!! شما قطعا از فرگمنت شدن دیسک اسمشو شنیدین ، شاید فقط شنیدین که دیسک دیفرگ بشه سرعتش میره بالا... شایدم میدونین معنیش چیه... حالا توضیحش میدیم😬</p>
<p>14 - نحوه ذخیره سازی لاگها روی هارد دیسک - که من راجع بهش چیزی نمیگم</p>
<p>15 - کش کردن درخواستها توسط سیستم عامل که از اسکیل بحث ما خارجه</p>
<p>16 - بحث دیوایس منیجینگ یا به قول ویندوزی ها درایو منیجینگ که بشدت تخصصیه و کار من نیست توضیحش</p>
<p>17 - ... انقدر فاکتور در این سرعت دخیل هست که من اگه بخوام بگم شاید هیچوقت نتونم این مقاله رو ببندم، همه بحثهاشم من بلد نیستم* بسیار بسیار تخصصی هست ، باید مراجعه کنید به خبره های فایل سیستم، من اطلاعات خیلی ناکامل محدود و اندکی دارم.</p>
<p>حالا زمان اتقال یا ترنسفر تایم، - که اول گفتم - میشه جمعِ تمــــــام این تاخیر ها و زمانهای موجود!</p>
<hr />
<p>حالا بریم سراغ توضیح قسمتهایی که گفتم، شروع کنیم از توضیح دو مورد اول که خیییلی باحال و مهمه:</p>
<p>رم مستقل از حرکات فیزیکیه اما هارددیسکها اتلاف زمان/انرژی توی حرکت فیزیکی دارن. </p>
<p>دو اتلاف وقت مشهور فیزیکی در هارددیسک: </p>
<p>1 - هارد دیسکها یه اتلاف دارن موقع چرخیدن خود دیسک 💿
مثلا یه داده ای که میخوای بخونی یا بنویسی ، توی این درجه از دیسک نیست(درجه ای که هد روی اون قرار داره) و مثلاً دیسک باید 260 درجه بچرخه تا توی اون درجه بخصوص بیفتته!
بهش میگن:</p>
<ul>
<li>rotational latency time</li>
</ul>
<p>2 - یک اتلاف وقت دیگه دارن اینکه اون سیخسیخک هارد که بهش میگن هد (head) باید بالا و پایین بره و دقیق روی شعاع مربوطه بیفته تا بتونه سکتورو پیدا کنه ، بهش میکن زمان بالا پایین شدن برای جستجو یا </p>
<ul>
<li>seek time</li>
</ul>
<p>همین دوتا حرکت فیزیکی کافیه تا هارد دیسک بشدت کند باشه و نشه ازش بجای یچیزی مثل رم جهت ذخیره‌سازی سریع اطلاعات محاسبات فعلی استفاده کرد، ولی خوبیش اینه که اطلاعات با قطع شدن برق از بین نمیرن:3</p>
<p>عکس زیرو ببینین:</p>
<p><img src="Files/9.jpg" alt="seek-time vs rotational-latency-time" /></p>
<p><em>یادم نمیاد منبع این عکس هم کجاست- اگر میدونید خبر بدین!</em></p>
<p>راستیه روتیشنال لیتنسی تایمه،
زمانی که دیسک باید بیکار وایسته تا دیسک بچرخه و اول سکتور مورد نظر بیاد.</p>
<p>چپیه سیک-تایمه،
زمانی که باید هد حرکت کنه بره روی شعاعی که سکتور مورد نظر هست.</p>
<hr />
<p><strong>بلاک اینترلیود بودن هارد دیسک:</strong></p>
<p>ما چند نوع اینترلیوینگ (معماری کار با بخشی از داده) داریم :</p>
<ul>
<li>معماری bit-interleaved:
یعنی که اطلاعات بیت بیت از یک حافظه ای خونده بشه</li>
<li>معماری byte-interleaved:
یعنی که اطلاعات بایت بایت از یک حافظه ای خونده بشه</li>
<li>معماری block-interleaved:
یعنی که اطلاعات بصورت چانکهایی که 1 بلاکه هست از هارد دیسک خونده بشه - سایز این بلاک رو سیستم عاملها مشخص میکنن.</li>
</ul>
<p>حالا فرقش چیه؟
قدیما اون اوایل که کامپیوتر ساخته شده بود میومدن یه بیت یه بیت میخوندن اطلاعاتو ، طبیعیه که خیلی کار بیخودیه ، چون تمام اطلاعاتی که ما باهاشون کار میکنیم حداقل یه بایت میطلبن
پس معماری بایت اینترلیود مطرحش شد و به کار گرفته شد…</p>
<p>امروزه شما نمیتونی یه بیت اطلاعات بنویسی توی دیسک یا روی رم یا تقریبا هر حافظه ای، باید حد اقل یک بایت بنویسی،
مثلا واسه یه متغیر بولین (TRUE/FALSE) فقط یه بیت کافیه ، اما همیشه 8 بیت میگیرن ، چونکه جنس حافظه بایت اینترلیود هست:)</p>
<p>حالا توی هارد دیسکها اومدن بلاک اینترلیود بودنو مطرح کردن ، وقتی طرف یه سیستم-کال میزنه به هارد دیسک و میگه که فلان بایت رو به من بده ، هارد دیسک میگه که من این همه دیسک بچرخونم هد بالا پایین کنم واسه یه بایت ؟! خب اگه بر فرض تو بعدش بگی بایت بعدیشم بده ، من دوباره باید برم هی دیسکو بچرخونم بایت بعدیشو پیدا کنم؟!
من مسخره تو نیستم! یه بلاک داده بهت میدم ، تو هر چقدرشو نیاز داری واکشی کن ، اگه بیشترم میخوای که بوگو!
مثلا 1024 بایت میده به سیستم عامل ، حالا سیستم عامل خودش فقط بایت اولشو میخواد ، میکشه بیرون و بقیه رو میریزه دور...
این قضیه الکی نیست ، روش 20 سال فکر شده و هزاران نفر آزمایش کردن و فهمیدن بلاک اینترلیود بودن بهتره از بایت اینتر لیود بودن برای HDD ها</p>
<p>حالا قضیه اینطوریه که رم byte-interleaved هست و هارددیسک block-interleaved</p>
<p>این قضیه خودش یک دنیا سرعتو HDD رو از رم کندتر میکنه در مقایسه.</p>
<hr />
<p><strong>تکنیک جلو-جلو خوندن هارددیسک یا read ahead :</strong></p>
<p>این تقریبا یه مفهومی شبیه چیزی که الان قبلش توضیح دادم داره ولی یه دنیا متفاوته!</p>
<p>مثلا هارد دیسک بر اساس رفتار میفهمه که سکتور هایی که پیاپی هستن، ممکنه نیازمند کاربر (سیستم عامل ) بشن، پس درسته که سیستم عامل نگفته که اون عداد بلاک رو به من برسون، ولی هارد دیسک میرسونه، که اگه به کارش اومد، دوباره نخواد سیستم کال بزنه و دستوراتش بره واسه درایور سخت افزار، و موتور هارد دیسک روشن بشه ، و بره جدول ذخیره سازیو دوباره بخونه، شماره سکتورو بفهمه بچرخونه و هد رو بالا پایین کنه ، و بطور مغناطیسی بخونه و برگردونه و......🥴
این الگوریتمهاش پیچیده هستن، میشه راجع بهش هزاران آزمایش کرد و هزاران الگوریتم ارائه داد...</p>
<hr />
<p><strong>ظرفیت اتخاذ شده برای تکنیک بافرینگ Buffering:</strong></p>
<p>بافر در علم کامپیوتر یعنی یه حافظه موقت.
اینکه بافرینگ HDD چیه ، واضحه یه تیکه حافظه توی رمه که اطلاعاتی که از هارددیسک واکشی شده و اومده توش نشسته تا یه فکری به حالش گرفته بشه.
اما این ظرفیت بافر کردنه خیلی متفاوته در سیستم عاملها، همین ظرفیت سرعت رو خیلی متاثر خودش میکنه...
من بیشتر از این واردش نمیشم ، از اساتید سیستم عامل باید سوال بشه :3</p>
<hr />
<p><strong>الگوریتمهای زمانبندی روی هارددیسک:</strong></p>
<p>بعضیها تصورشون اینه که در هر لحظه فقط یک عمل I/O برای هارد دیسک میره،
ولی فی الواقع ، در هر لحظه که با هارد دیسک تراکنش داریم ، هزاران هزار درخواست میره که بعضی هاشون درخواست نوشتن هستن و بعضی هاشون درخواست خوندن...</p>
<p>هارد دیسکها فقط یه هد دارن و یه دیسک ( اون سه لایه ها مد نظر ما نیست - اونا هر کدوم یه هارد دیسک حساب میشن ) وقتی یه هد داریم و یک دیسک طبیعیه که باید اسکجولینگ خیلی خفنی پیاده کنیم، تا بتونیم درخواست های داده شده رو کاملا ارضا کنیم.</p>
<p>اسکجولینگ خیلی خیلی مبحث پیچیده ای هست ، جدیا از بحث های سیستم عاملیش و نرم افزاریش، باید الگوریتم های سخت افزاری خفنی داشته باشیم تا بتونیم حرکاتمونو بیشتر بهینه کنیم.</p>
<p>مثلا الگوریتمی وجود داره به اسم الویتور یا آسانسور، که میگه که حالا که دیسک داره میچرخه و روی این سکتور ها هستی، این بلاکم بده مال درخواست سوممونه تا برسیم به سکتور درخواست اول - یا اینکه حالا که داریم اینوری سیک میکنیم روی هد همینو سیسک کن و برنگرد عقب که ادامه رو بخونی ، همونو ادامه بده درخواست پنجم روی اون نواره ، بعدا موقع برگشت دستور اولم میخونیم.</p>
<p>مثل یک اسانسوری که داره میره بالا و طبقه 16 عه داره میره طبقه 20 ، یکی که طبقه 1 باشه دکمه رو بزنه نمیاد پایین سوارش کنه و بعدا بره 20! میره طرف 20 رو سروار میکنه بعدا میاد 1 - اینو وسط یکی طبقه 2 هم باشه سوارش میکنه.
راجع به آسانسور به تنهایی میشه کتاب نوشت …:))</p>
<p>هزاران الگوریتم دیگه وجود دارن!
یک بحث بهینه‌سازی خیلی شاخی داره<em>-</em></p>
<p>که اگه این بحثها نبودن واسه یه I/O زدن روی دیسک باید 70 سال منتظر مینشستیم.</p>
<hr />
<p><strong>نحوه چینش فایلها (داده ها):</strong></p>
<p>این شاید مهم ترین بحثه ...
هیچوقت نمیشه از دیسک بعنوان مموری پردازشی استفاده کرد‌، چون نحوه چینش داده هاش خیلی خیلی سخته...</p>
<p><em>یه مقاله هم راجع به ریکاوری مینویسم؛ اونجا فرگمنت شدن دیسک رو توضیح میدم</em></p>
<p>دیسک فرگمنت شده:</p>
<p><img src="Files/10.jpg" alt="Fragmented HDD" /></p>
<p>خلاصه که همیشه سرعت هایی که بر آورد میکنید باید بر اساس یک دیسک فرگمنت شده باشه ، که خودش هزاران بار ماجرا رو کندتر میکنه،
توی RAM ما فرگمنت شدن نداریم یعنی داریم؛ ولی روی سرعت به اون شکل تاثیر نداره - اصلا بیس کارش فرگمنت بودنه، رم همونطور که توضیح دادم به تمام خونه های خودش به یک زمان مساوی «دسترسی تصادفی» دسترسی داره.</p>
<p>خوندن اطلاعات و کار کردن با جداول روی هارددیسک (چیزهایی مثل inode یا mft) کار خیــــلی ریسورس-بر و زمان بریه.</p>
<p>پس خلاصه ماجرا این میشه که،
ترنسفر تایم هارددیسک که از مجموع همه مواردی که گفتم + هزار مورد مطلب دیگه تاثیر میپذیره، خیلی کند هست.
حرکت فیزیکی دیسک بقدری کند هست که با چشم قابل دیدنه !</p>
<p>توی رم معماری با گیت منطقی پیاده شده و سرعتش وابسته به سرعت حرکت جریان (الکترون آزاد) هست.</p>
<p>یه کلیپم دارم که یک کپی پبیست ساده در هارد دیسک رو بصورت اسلوموشن نشون میده،
حرکات فیزیکی هارددیسک، وقتی درش رو باز میکنیم و میبینیم😬:</p>
<p><a href="https://www.youtube.com/watch?v=3owqvmMf6No">https://www.youtube.com/watch?v=3owqvmMf6No</a></p>
<p>حرکتی که با چشم قابل دیدن هست و بار دوربین قابل ظبط، قطعا خیلی کند تر از سرعت حرکت الکترونهاست:)
و در کل، بطور متوسط 100 هزاربار کندتر بودن کاملا منطقی هست، اما بیاین با دانش برنامه‌نویسی که داریم، خودمون هم دست به آچار بشیم و تست کنیم ببینیم در عمل جریان چجوریه!</p>
<hr />
<p>میخوایم یکسری برنامه بنویسیم که ادعایی که کردیم (کند تر بودن هارد دیسک از رم به میزان 100 هزار بار) رو تست کنیم.</p>
<p>زبان برنامه‌نویسی مورد علاقه من <code>PHP</code> هست، اما وقتی بحث سنجش پیچیدگی زمانی/ریسورسی الگوریتمها میاد وسط و میخوایم آزمایشهایی رو راجع به مقایسه زمان/ریسورس مصرفی متدهای مختلف انجام بدیم، من نظرم اینه که همیشه باید حدالقمدور از زبانهای برنامه‌نویسی نزدیک به سطح پایینتر استفاده کنیم. زبانهایی کامپایلری مثل <code>C</code> و <code>C++</code> همیشه به ما دسترسی بسیار بیشتر،‌ نزدیکتر و بهینه‌تری به ریسورسهایی مثل رم و دیسک میدن و همچنین بخاطر ساختار کامپایلری‌شون، کدی ترجمه شده به زبان ماشین میدن که صرفاً نقش اجرای الگوریتم رو بر عهده داره و خیلی کمتر درگیر محاسبات پرت میشن. با استفاده از این زبانها، نتیجه آزمایشهای ما متأثر از زمان/ریسورس پرتی که صرف تفسیر کد یا اجرای فرایندهای اجرایی مفسر و مترجم و کامپایلر هست نمیشه. برای همین توی این آزمایشمون از زبان <code>C++</code> استفاده میکنیم.</p>
<p>کد زیر رو در نظر بگیرید:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_write_test.cpp">فایل کد</a></p><br />
<p>این قطعه کد زمان اجرا و میزان رم مصرفی مربوط به یک قطعه کد خاص رو اندازه‌گیری میکنه، اون قطعه کد خاص، سگمنت زیر هست که به اندازه دقیقاً 1 گیگابایت (1073741824 بایت) فضای رم رو تخصیص میده به یک آرایه از نوع کرکتر، اگه بخوام به زبان ساده بگم این قطعه کد که میبینید، دقیقاً 1 گیگابایت اطلاعات رو روی رم ذخیره میکنه:</p><br />
<pre><code class="language-cpp">char* arr = new char[1073741824];
for(int i = 0; i &lt; 1073741824 ; i++)
    arr[i] = 'A';</code></pre><br />
<p>با اجرای این کد، میتونیم با یه تقریب خوبی بسنجیم که ذخیره کردن 1 گیگابایت از اطلاعات روی مموری بصورت دسترسی تصادفی (Random Access) چه مقدار زمانی طول میکشه و اینکه چقدر از مموری (RAM) استفاده میشه (منطقاً دقیقاً باید 1 گیگابایت استفاده بشه). این کد کزمان اجرای اون قطعه سگمنت مذکور رو یک بار با اساتفاده از کلاکها توی کتابخونه ctime میسنجه و بار دیگر با استفاده از کتابخونه chrono. بدین ترتیب ما میتونیم بگیرم زمان خروجی ما نسبتا دقیق هست، یادتون باشه که اینکلود کردن iostream توی این کامپایلر من خودش کتابخونه ctime رو هم به کد اضافه میکنه، اگه توی کامپایلر شما این قضه کار نکرد، حتما کتابخونه رو دستی اینکلود کنین:</p><br />
<p><code>#include &lt;ctime&gt;</code></p><br />
<p>بیاین کد رو اجرا کنیم تا ببینیم پاسخ چیه، من روی یه ماشین لینوکس هستم، پس کد رو با <code>g++ RAM_test.cpp</code> کامپایل میکنم و با <code>./a.out</code> اجرا میکنم.</p><br />
<p>نکته: همیـــشه یادتون باشه که در اینجور آزمایشها و مقایسه ها، انجام آزمایش (اجرای کد) رو حداقل 3 بار در شرایط مختلف تکرار کنید و متوسط کلی رو بعنوان پاسخ در نظر بگیرید، در هر لحظه توی یک ماشین کامپیوتری هزارن پراسس دیگر وجود دارن که با ریسورسها در حال تعامل هستن، رفتار این پراسس ها ممکنه در زمانهای متفاوت، تأثیری روی نتیجه آزمایش شما هم بذاره.</p><br />
<p>نکته2: یه دستور معروف یونیکسی هست به اسم <code>time</code> که با اون میتونیم یسکری اطلاعات جانبی راجع به کامندی که ران میکنیم داشته باشیم. من از این پکیج استفاده میکنم که زمانها و سی‌پی‌یو مصرفی حین اجرای برنامه رو مانیتور کنم. بعد از اجرا دقیقاً توضیح میدم معنی این اطلاعات چیه.</p><br />
<p>اجرای کد:</p><br />
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_write_test.cpp 

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out 
Execution Time (Based on ctime): 2501.88 ms
Execution Time (Based on chrono): 2501.97 ms
Memory Usage: 1046800 KB

real    2.51s
user    2.36s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2440.13 ms
Execution Time (Based on chrono): 2440.23 ms
Memory Usage: 1046864 KB

real    2.45s
user    2.32s
sys     0.13s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2446.16 ms
Execution Time (Based on chrono): 2446.23 ms
Memory Usage: 1046772 KB

real    2.45s
user    2.32s
sys     0.13s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2444.35 ms
Execution Time (Based on chrono): 2444.5 ms
Memory Usage: 1046848 KB

real    2.45s
user    2.29s
sys     0.16s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2515.03 ms
Execution Time (Based on chrono): 2515.09 ms
Memory Usage: 1046832 KB

real    2.52s
user    2.39s
sys     0.13s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2438.22 ms
Execution Time (Based on chrono): 2438.28 ms
Memory Usage: 1046844 KB

real    2.45s
user    2.32s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2493.81 ms
Execution Time (Based on chrono): 2493.94 ms
Memory Usage: 1046784 KB

real    2.50s
user    2.35s
sys     0.15s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2501.99 ms
Execution Time (Based on chrono): 2502.09 ms
Memory Usage: 1046852 KB

real    2.51s
user    2.37s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2459.47 ms
Execution Time (Based on chrono): 2460.05 ms
Memory Usage: 1046872 KB

real    2.47s
user    2.32s
sys     0.15s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2429.63 ms
Execution Time (Based on chrono): 2429.75 ms
Memory Usage: 1046772 KB

real    2.43s
user    2.32s
sys     0.12s
cpu     99%
</code></pre><br />
<p>من این کد رو توی 10 بازه زمانی مختلف که سیستم من هر بار درگیر محاسبات متفاوتی بود اجرا کردم و خروجی به شرح بالا بود، همونطور که میبینید زمان اجرا با یه تقریب خاصی در یک رنجه، اما هر بار تغییرات جزئی داره که این نتیجه کارکردهای پارلل سیستم عامل ما هست، بعداً راجع به محاسبات موازی سیستم عامل یه مقاله مینویسم، اما مساله جالب دیگه اینه که میزان مموری مصرفی هم توی هر بار اجرا متفاوت بوده و این کمی عجیب بنظر میرسه… اما میشه تخصصی بررسیش کرد و اون موقع میبینیم که کاملاً معقوله. بررسی تخصصیش از حوصله این مقاله خارجه اما، بطور خیلی خلاصه میتونیم بگیم که کارکرد کد به کارکرد کتابخونه‌ها و توابعی که از سیستم اینکلود کردیم وابسته هست، این توابعی که کال کردیم هر بار اون زیر باک سیستم عامل دیتاهای متفاوتی رو وارد رم میکنن، و همین باعث متفاوت شدن میزان دیتای نشسته روی رم میشه، اما در کل روی رنج 1 گیگابایتی هست که سگمنت مذکور ما مصرف میکنه.</p><br />
<p>و حالا بریم سراغ توضیحات تخصصی کامند تایم که شامل ریپورتهایی از قبیل real و user و sys و cpu هست و ببینیم اینا چه معنی میدن. </p><br />
<p><strong>زمان Real</strong></p><br />
<p>کل زمانی که طول کشیده که پراسس شروع بشه و به اتمام برسه، انگار که با یه کرنومتر بسنجیمش. به زبان تخصصی این زمان شامل همه زمانها میشه، زمان محاسبات و زمانهایی که پراسس منتظر میمونده (بلاک بوده) و زمانهایی که منتظر I/O بوده.</p><br />
<p><strong>زمان User</strong></p><br />
<p>زمانی هست که سی‌پی‌یو صرف محاسبات برنامه میکنه، و به زبان تخصصی زمانی هست که پراسس روی سی‌پی‌یو نشسته و داره اجرا میشه (بهش میگن user-mode)</p><br />
<p><strong>زمان Sys</strong></p><br />
<p>زمانی هست که سی‌پی‌یو مشغول تسکهایی بوده که کرنل سیستم عامل بخاطر پراسس داشته انجام میداده، مثلاً مموری الوکیشن و I/O ها… (به این قسمت میگن kernel-mode)</p><br />
<p>به دو حالت اجرای پراسس ها روی پردازنده اشاره کردم به اسامی یوزر-مود و کرنل-مود. اینا مودهای اجرای برنامه توی سیستمهای یونیکسی یا هر سیستم مموری-پروتکتد دیگری هستن. بین یوزر-مود و کرنل-مود تفاوتهایی وجود داره که من سعی میکنم خیلی خیلی خلاصه توضیح بدم و بعدش منبع بدم که توضیحات تخصصی‌تر و مفصل رو از اونجا مطالعه بفرمائین:</p><br />
<p><strong>کرنل-مد/Kernel-mode</strong></p><br />
<p>اگه کدی توی این حالت اجرا بشه، اون قطعه کد دسترسی کامل و بدون محدودیتی به سخت‌افزار داره. میتونه هر سیستم کالی رو اجرا کنه، مثل هر اینستراکشنی برای CPU یا تعامل با هر قسمت رم. این بالاترین سطح دسترسیه و در پایین‌ترین لایه اتفاق می‌افته. اگه توی کدهای اجرایی این لایه خرابکاری یا اشکالی پیش بیاد خطرناکه و کل سیستم رو به مخاطره میندازه برای همین کدها و فانکشنهای معتمد سیستم عامل توی این حالت اجرا میشن.</p><br />
<p><strong>یوزر-مد/User-mode</strong></p><br />
<p>توی این حالت بر عکس حالت قبلی، مجری برنامه دسترسی مستقیم به سخت‌افزار نداره و نمیتونه مستقیماً با مجودیتهایی مثل رم و دیسک تعامل کنه، بلکه نیازمند یه API از طرف سیستم عامل هست که با اون تعامل داشته باشه و از اون بخواد که براش اعمالش رو انجام بده. بعداً یه مقاله راجع به مفهوم API مینویسم. بنابرین این حالت امن تره و کد نسبت به سخت‌افزار ایزوله هست و اگر اشکالی پیش بیاد قابل جبرانه. بیشتر کدهایی که توی سیستم انجام میشن روی این مود هستن.</p><br />
<p>منابع این قسمت:</p><br />
<ul><br />
<li><em><a href="https://blog.codinghorror.com/understanding-user-and-kernel-mode">https://blog.codinghorror.com/understanding-user-and-kernel-mode</a></em></li><br />
<li><em><a href="https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys">https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys</a></em></li><br />
<li><em><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems</a></em></li><br />
<li><em><a href="https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine">https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine</a></em></li><br />
<li><em><a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></em></li><br />
</ul><br />
<p>حالا میتونیم یه تخمینی از متوسط زمان داشته باشیم: </p><br />
<pre><code class="language-md">(2501.88+2440.13+2446.16+2444.35+2515.03+2438.22+2493.81+2501.99+2459.47+2429.63) / 10 = 24670.67 / 10 = 2467.067
(2501.97+2440.23+2446.23+2444.5+2515.09+2438.28+2493.94+2502.09+2460.05+2429.75) / 10 = 24672.13 / 10 = 2467.213
(1046800+1046864+1046772+1046848+1046832+1046844+1046784+1046852+1046872+1046772) / 10 = 10468240 / 10 = 1046824
(2.51s+2.45s+2.45s+2.45s+2.52s+2.45s+2.50s+2.51s+2.47s+2.43s) / 10 = 24.74 / 10 = 2.474
(2.36s+2.32s+2.32s+2.29s+2.39s+2.32s+2.35s+2.37s+2.32s+2.32s) / 10 = 23.36 / 10 = 2.336
(0.14s+0.13s+0.13s+0.16s+0.13s+0.12s+0.15s+0.14s+0.15s+0.12s) / 10 = 1.37 / 10 = 0.137
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2467.067 ms
* Average Execution Time(Based on chrono): 2467.213 ms
* Average Memory Usage: 1046824 KB
* Average Real Time: 2.474 s
* Average User Time: 2.336 s
* Average Sys Time: 0.137 s
* Average CPU Usage: 99 %</code></pre><br />
<p>این نتایج رو در ذهن داشته باشین بعداً برای مقایسه بهش برمیگردیم. همین اوردر زمانی ذخیره سازی دیتا بصورت دسترسی تصادفی روی رم، سرعتی که لازم داریم برای مقایسه رو به ما میده، سرعتش در عمل برابری میکنه با خوندن چیزی از رم بصورت دسترسی تصادفی.</p><br />
<p>حالا بریم سراغ هارددیسک و ببینیم که خوندن/نوشتن یک گیگابایت از دیتا روی HDD چه مقدار زمان/ریسورس مصرف میکنه. البته در بحث این مقایسه دیگه ریسورسش (میزان رم مصرفیش) مد نظر ما نیست، بلکه زمانش برای ما مهمه. وقتی داریم رم رو با دیسک مقایسه میکنیم، دیگه نباید رمی که خود اعمال I/O مصرف میکنن رو بسنجیم.</p><br />
<p>کد زیر رو در نظر بگیرید:</p><br />
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    ofstream outfile;
    char character = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    outfile.open("output.txt");
    if (!outfile.is_open()) {
        cout &lt;&lt; "Error opening file!" &lt;&lt; endl;
        return 1;
    }
    for (int i = 0; i &lt; 1073741824; i++) {
        outfile &lt;&lt; character;
    }
    outfile.close();
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_write_test.cpp">فایل کد</a></p><br />
<p>این کد یه فایل به اسم output.txt باز میکنه (اگر نباشه میسازه و اگر باشه اوررایت میکنه{به اوررایتش برمیگردم}) و توش 1 گیگابایت داده مینویسه. من به رسم آزمایش 10 بار اجراش میکنم:</p><br />
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_write_test.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out 
Execution Time (Based on ctime): 9536.65 ms
Execution Time (Based on chrono): 9538.49 ms
Memory Usage: 0 KB

real    9.54s
user    8.85s
sys     0.68s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9530.77 ms
Execution Time (Based on chrono): 10150.1 ms
Memory Usage: 0 KB

real    10.15s
user    8.82s
sys     0.72s
cpu     93%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9625.24 ms
Execution Time (Based on chrono): 10063.4 ms
Memory Usage: 0 KB

real    10.07s
user    8.99s
sys     0.64s
cpu     95%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9655.58 ms
Execution Time (Based on chrono): 9657.09 ms
Memory Usage: 0 KB

real    9.66s
user    8.96s
sys     0.70s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9479.76 ms
Execution Time (Based on chrono): 9634.6 ms
Memory Usage: 0 KB

real    9.64s
user    8.89s
sys     0.60s
cpu     98%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9477.25 ms
Execution Time (Based on chrono): 9641.66 ms
Memory Usage: 0 KB

real    9.65s
user    8.92s
sys     0.56s
cpu     98%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9468.07 ms
Execution Time (Based on chrono): 9475.96 ms
Memory Usage: 0 KB

real    9.48s
user    8.70s
sys     0.77s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9761.29 ms
Execution Time (Based on chrono): 10151.8 ms
Memory Usage: 0 KB

real    10.16s
user    9.05s
sys     0.72s
cpu     96%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9632.74 ms
Execution Time (Based on chrono): 10079 ms
Memory Usage: 0 KB

real    10.08s
user    8.92s
sys     0.72s
cpu     95%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9536.97 ms
Execution Time (Based on chrono): 9540.68 ms
Memory Usage: 0 KB

real    9.55s
user    8.89s
sys     0.65s
cpu     99%</code></pre><br />
<p>و متوسط نتایج آزمایش به شرح زیره:</p><br />
<pre><code class="language-md">(9536.65+9530.77+9625.24+9655.58+9479.76+9477.25+9468.07+9761.29+9632.74+9536.97) / 10 = 95704.32 / 10 = 9570.432
(9538.49+10150.1+10063.4+9657.09+9634.6+9641.66+9475.96+10151.8+10079+9540.68) / 10 = 97932.78 / 10 = 9793.278
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(9.54s+10.15s+10.07s+9.66s+9.64s+9.65s+9.48s+10.16s+10.08s+9.55s) / 10 = 97.98 / 10 = 9.798
(8.85s+8.82s+8.99s+8.96s+8.89s+8.92s+8.70s+9.05s+8.92s+8.89s) / 10 = 88.99 / 10 = 8.899
(0.68s+0.72s+0.64s+0.70s+0.60s+0.56s+0.77s+0.72s+0.72s+0.65s) / 10 = 6.76 / 10 = 0.676
(99%+93%+95%+99%+98%+98%+99%+96%+95%+99%) / 10 = 971 / 10 = 97.1


Therefore:

* Average Execution Time(Based on ctime): 9570.432 ms
* Average Execution Time(Based on chrono): 9793.278 ms
* Average Memory Usage: 0 KB
* Average Real Time: 9.798 s
* Average User Time: 8.899 s
* Average Sys Time: 0.676 s
* Average CPU Usage: 97.1 %</code></pre><br />
<p>خب اینکه تقریباً 5 برابر کند تره! پس اون همه خزعبلات و دک و پز که عای 10 هزار برابر بطور متوسط کند تره چیشد؟! عجله نکنید، بیاین یواش یواش فاکتورهای دخیل رو به آزمایش اضافه کنیم.<br />
فرض کنید میخوایم 1 گیگابایت دیتایی که وجود داره رو اوررایت کنیم.</p><br />
<p>برای سنجش این حرکت داخل رم، من کد رو به این شکل تغییر میدم:</p><br />
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'B';    
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_overwrite_test.cpp">فایل کد</a></p><br />
<p>و اجرا میکنم:</p><br />
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_overwrite_test.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out              
Execution Time (Based on ctime): 2315.81 ms
Execution Time (Based on chrono): 2315.86 ms
Memory Usage: 0 KB

real    4.76s
user    4.61s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2321.07 ms
Execution Time (Based on chrono): 2321.15 ms
Memory Usage: 0 KB

real    4.80s
user    4.66s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2305.9 ms
Execution Time (Based on chrono): 2305.95 ms
Memory Usage: 0 KB

real    4.78s
user    4.67s
sys     0.11s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2331.96 ms
Execution Time (Based on chrono): 2332.03 ms
Memory Usage: 0 KB

real    4.79s
user    4.70s
sys     0.09s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2291.69 ms
Execution Time (Based on chrono): 2296.94 ms
Memory Usage: 0 KB

real    4.74s
user    4.57s
sys     0.16s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2336.1 ms
Execution Time (Based on chrono): 2339.92 ms
Memory Usage: 0 KB

real    4.85s
user    4.71s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2330.54 ms
Execution Time (Based on chrono): 2330.6 ms
Memory Usage: 0 KB

real    4.82s
user    4.70s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2283.55 ms
Execution Time (Based on chrono): 2283.58 ms
Memory Usage: 0 KB

real    4.72s
user    4.59s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2328.87 ms
Execution Time (Based on chrono): 2328.91 ms
Memory Usage: 0 KB

real    4.79s
user    4.67s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2295.38 ms
Execution Time (Based on chrono): 2296.14 ms
Memory Usage: 0 KB

real    4.75s
user    4.60s
sys     0.15s
cpu     99%</code></pre><br />
<p>و متوسط نتیجه:</p><br />
<pre><code class="language-md">(2315.81+2321.07+2305.9+2331.96+2291.69+2336.1+2330.54+2283.55+2328.87+2295.38) / 10 = 23140.87 / 10 = 2314.087
(2315.86+2321.15+2305.95+2332.03+2296.94+2339.92+2330.6+2283.58+2328.91+2296.14) / 10 = 23151.08 / 10 = 2315.108
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(4.76s+4.80s+4.78s+4.79s+4.74s+4.85s+4.82s+4.72s+4.79s+4.75s) / 10 = 47.8 / 10 = 4.78
(4.61s+4.66s+4.67s+4.70s+4.57s+4.71s+4.70s+4.59s+4.67s+4.60s) / 10 = 46.48 / 10 = 4.648
(0.14s+0.14s+0.11s+0.09s+0.16s+0.12s+0.12s+0.12s+0.12s+0.15s) / 10 = 1.27 / 10 = 0.127
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2314.087 ms
* Average Execution Time(Based on chrono): 2315.108 ms
* Average Memory Usage: 0 KB
* Average Real Time: 4.78 s
* Average User Time: 4.648 s
* Average Sys Time: 0.127 s
* Average CPU Usage: 99 %</code></pre><br />
<p>همونطور که میبینید زمان اوررایت کردن برابری میکنه با زمان رایت کردن.<br />
نکته1: قسمت مد نظر ما برای مقایسه صرفاً زمانی هست که اون سگمنت بخصوص کد یعنی:</p><br />
<pre><code class="language-cpp">for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'B'; </code></pre><br />
<p>انجام میشده. که در‌واقع میشه:</p><br />
<pre><code class="language-md">* Average Execution Time(Based on ctime): 2314.087 ms
* Average Execution Time(Based on chrono): 2315.108 ms</code></pre><br />
<p>نکته2: میزان مموری مصرفی این سگمنت کد 0 ریپورت شده چون هیچ مموری الوکیشن جدیدی نداشتیم (در حقیقت داشتیم مثلاً برای شمارنده حلقه فور، ولی اینقدر کوشولو هست که توی اوردر کیلوبایت دیده نشده) – وقتی ما حافظه‌ای نیو نکردیم، و صرفاً قبلی رو اوورایت کردیم مموری یوزیج جدیدی ریپورت نشده. ولی در‌واقع ما با 1 گیگابایت مموری کار کردیم.</p><br />
<p>حالا بریم سراغ هارددیسک، من از همون کد قبلی استفاده میکنم، منتهی این بار دیگه فایلهای 1 گیگی ساخته شده پیشین رو حذف (rm) نمیکنم تا اوررایت بشن:</p><br />
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_write_test.cpp    

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out 
Execution Time (Based on ctime): 10162.1 ms
Execution Time (Based on chrono): 16532.7 ms
Memory Usage: 0 KB

real    16.54s
user    9.30s
sys     0.87s
cpu     61%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9961.45 ms
Execution Time (Based on chrono): 19035.1 ms
Memory Usage: 0 KB

real    19.04s
user    9.10s
sys     0.86s
cpu     52%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9925.02 ms
Execution Time (Based on chrono): 19885.7 ms
Memory Usage: 0 KB

real    19.89s
user    9.14s
sys     0.79s
cpu     49%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9927.78 ms
Execution Time (Based on chrono): 20518.4 ms
Memory Usage: 0 KB

real    20.52s
user    9.04s
sys     0.89s
cpu     48%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9996.59 ms
Execution Time (Based on chrono): 17915.4 ms
Memory Usage: 0 KB

real    17.92s
user    9.16s
sys     0.84s
cpu     55%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9659.78 ms
Execution Time (Based on chrono): 19085.9 ms
Memory Usage: 0 KB

real    19.09s
user    8.91s
sys     0.76s
cpu     50%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 10051.7 ms
Execution Time (Based on chrono): 19261.9 ms
Memory Usage: 0 KB

real    19.27s
user    9.25s
sys     0.81s
cpu     52%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 10124.3 ms
Execution Time (Based on chrono): 19965.3 ms
Memory Usage: 0 KB

real    19.97s
user    9.31s
sys     0.82s
cpu     50%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9867.27 ms
Execution Time (Based on chrono): 19433.7 ms
Memory Usage: 0 KB

real    19.44s
user    9.05s
sys     0.82s
cpu     50%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9850.91 ms
Execution Time (Based on chrono): 18046 ms
Memory Usage: 0 KB

real    18.05s
user    8.96s
sys     0.89s
cpu     54%</code></pre><br />
<p>متوسط میگیریم:</p><br />
<pre><code class="language-md">(10162.1+9961.45+9925.02+9927.78+9996.59+9659.78+10051.7+10124.3+9867.27+9850.91) / 10 = 99526.9 / 10 = 9952.69
(16532.7+19035.1+19885.7+20518.4+17915.4+19085.9+19261.9+19965.3+19433.7+18046) / 10 = 189680.1 / 10 = 18968.01
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(16.54s+19.04s+19.89s+20.52s+17.92s+19.09s+19.27s+19.97s+19.44s+18.05s) / 10 = 189.73 / 10 = 18.973
(9.30s+9.10s+9.14s+9.04s+9.16s+8.91s+9.25s+9.31s+9.05s+8.96s) / 10 = 91.22 / 10 = 9.122
(0.87s+0.86s+0.79s+0.89s+0.84s+0.76s+0.81s+0.82s+0.82s+0.89s) / 10 = 8.35 / 10 = 0.835
(61%+52%+49%+48%+55%+50%+52%+50%+50%+54%) / 10 = 521 / 10 = 52.1


Therefore:

* Average Execution Time(Based on ctime): 9952.69 ms
* Average Execution Time(Based on chrono): 18968.01 ms
* Average Memory Usage: 0 KB
* Average Real Time: 18.973 s
* Average User Time: 9.122 s
* Average Sys Time: 0.835 s
* Average CPU Usage: 52.1 %</code></pre><br />
<p>اهوع! نتیجه 10 برابر کندتر شد. اما هنوز صبر کنید:)) داستان ادامه داره…</p><br />
<p>نکته1: به زمان اجرای اولین اوررایت HDD نگاه کنید و به زمان متوسط محاسبه شده نگاه کنید، و متوجه میشین که چرا گفتم هر آزمایش رو باید حداقل چندین بار تکرار کنیم.</p><br />
<p>نکته2: همونطور که میبینین زمان محاسبه شده توسط chrono خیلی بیشتر (تقریباً دو برابر) زمان محاسبه شده توسط ctime هست و زمان واقعی اجرای اون بلاک کد رو بیان میکنه. اما چرا؟<br />
داستان یچیزی شبیه اون زمانهای real و user و sys هست که توی بحث کامند time گفتم، دلیل علمی اینه که این دو کتابخونه زمان رو به روشهای متفاوتی محاسبه میکنن. Ctime یه کتابخونه مختص زبان سی هست که اینجا با استفاده از فانکشن <code>clock()</code> زمان رو محاسبه میکنه، اما نه زمان دقیق رو، بلکه زمانی رو که CPU صرف محاسبات این پراسس فعلی کرده. اما این گزاره بازم دقیق نیست، یکمی به زبان تخصصی تر میگم، سی‌تایم با استفاده از فانکشن کلاک، تعداد کلاکهایی که CPU حین محاسبات همین برنامه بخصوص زده رو ثبت میکنه، و سپس معادل این کلاکهارو به زمان ثانیه‌ای بیان میکنه. صرفاً یعنی CPU روی این پراسس خاص چند تا کلاک زده، این معنیش اینه که زمانی که ما داشتیم I/O میزدیم و یا منتظر ریسورس یا I/O بلاک بودیم یا منتظر دیگر پراسسها بودیم رو توی محاسباتش دخیل نمیکنه، در صورتی که سنجش میزان زمان I/O اصلاً بخش بزرگی از محاسبات ماست! اما chrono داستانی کاملاً متفاوت داره… <br />
کتابخونه  chrono زمانی که روی متد های‌رزولوشن (<code>high_resolution_clock</code>) کال میشه، به اصطلاح زمان دقیق ساعت دیواری رو محاسبه میکنه، از نقطه شروع تا نقطه پایان. این زمان شامل اینتراپتها و I/O های داستان هم هست. پس این زمان دقیقی هست که باهاش مقایسه رو انجام میدیم.</p><br />
<hr /><br />
<p>یکسری لینک پرسش و پاسخ مرتبط با این موضوع:</p><br />
<ul><br />
<li><em><a href="https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access">https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access</a></em></li><br />
<li><em><a href="https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk">https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk</a></em></li><br />
<li><em><a href="https://queue.acm.org/detail.cfm?id=1563874">https://queue.acm.org/detail.cfm?id=1563874</a></em></li><br />
</ul><br />
<p>و تمام، هارددیسک بطور متوسط 100000 بار از رم کند تره:))</p><br />
<h2>کپی رایت</h2><br />
<p>این یک مقاله آزاد و متن‌باز تحت مجوز GFDL1-3 می‌باشد، بنابراین اجازه کپی، توزیع و/یا تغییر این سند با شرایط مجوز GNU Free Documentation License داده شده است.</p><br />
<h2>منابع</h2><br />
<ul><br />
<li><a href="https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm">https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm</a></li><br />
<li><a href="https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041">https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041</a></li><br />
<li>Database System Concepts, 6th Edition</li><br />
<li><a href="http://www.foundersatwork.com/steve-wozniak.html">http://www.foundersatwork.com/steve-wozniak.html</a></li><br />
<li><a href="https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90">https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90</a></li><br />
<li><a href="https://blog.codinghorror.com/understanding-user-and-kernel-mode">https://blog.codinghorror.com/understanding-user-and-kernel-mode</a></li><br />
<li><a href="https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys">https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys</a></li><br />
<li><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems</a></li><br />
<li><a href="https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine">https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine</a></li><br />
<li><a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></li><br />
</ul></div><script src="https://tadavomnist.github.io/assets/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://tadavomnist.github.io/assets/js/MathJax.js" type="text/javascript"></script><script type="text/javascript">MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});</script><script>document.addEventListener("DOMContentLoaded", ev => document.body.querySelectorAll("#container > *").forEach(elm => elm.setAttribute("dir", "auto")));</script><script>const toggleButton = document.getElementById("dark-mode-toggle");const container = document.getElementById("container");const body = document.body;if (toggleButton.checked) {enableDarkMode();}toggleButton.addEventListener("click", () => {if (!toggleButton.checked) {disableDarkMode();} else {enableDarkMode();}});function enableDarkMode() {body.classList.add("dark-mode");localStorage.setItem("darkModeEnabled", true);}function disableDarkMode() {body.classList.remove("dark-mode");localStorage.removeItem("darkModeEnabled");}</script></body></html>