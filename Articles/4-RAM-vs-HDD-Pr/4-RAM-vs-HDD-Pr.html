<!DOCTYPE HTML><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><title>RAM vs HDD</title> <link href="https://tadavomnist.github.io/assets/css/highlightjs.default.min.css" rel="stylesheet"/><style type="text/css">*,pre code,table,table tr{padding:0}hr,html{overflow:hidden}*{box-sizing:border-box;outline:0;margin:0}body,html{position:relative;width:100vw;height:100vh}html{color-scheme:light}body{padding:10px 15px;overflow:hidden auto;overflow-wrap:break-word;word-wrap:break-word;font:16px/1.4 Helvetica,Arial,sans-serif;color:#333}body,html,table tr{background-color:#fff}.highlight pre,code,pre,tt{background-color:#f8f8f8;direction:ltr!important}table tr :is(th,td){border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{position:relative;box-sizing:content-box;font-weight:700;padding:15px 0;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;border:0;border-bottom:1px solid #ddd}a{color:#4183c4}a.absent{color:#c00}ol,ul{padding-left:15px;margin:0 7px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr :is(th,td) :first-child{margin-top:0}table tr :is(th,td) :last-child{margin-bottom:0}img{max-width:100%;pointer-events:none}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;overflow-wrap:break-word;border:1px solid #eaeaea;border-radius:3px}tt{white-space:nowrap}pre code{white-space:pre;border:none}.highlight pre,pre{border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;margin:.8em 0 1em;border-radius:3px;max-width:calc(100% - 2px)}#container{width:960px;margin: 0 auto;}.dark-mode{background-color:#000;color:#fff;}.dark-mode table tr{background-color:#000}.dark-mode table tr:nth-child(2n){background-color:#333}.dark-mode code{background-color:#212121;color:rgb(0,183,255);}.dark-mode pre{background-color:#433f3f !important;}*,*:before,*:after{box-sizing:border-box;}.toggle{cursor:pointer;display:inline-block;}.toggle-switch{display:inline-block;background:#ccc;border-radius:16px;width:58px;height:32px;position:relative;vertical-align:middle;transition:background 0.25s;}.toggle-switch:before,.toggle-switch:after{content:"";}.toggle-switch:before{display:block;background:linear-gradient(to bottom,#fff 0%,#eee 100%);border-radius:50%;box-shadow:0 0 0 1px rgba(0,0,0,0.25);width:24px;height:24px;position:absolute;top:4px;left:4px;transition:left 0.25s;}.toggle:hover .toggle-switch:before{background:linear-gradient(to bottom,#fff 0%,#fff 100%);box-shadow:0 0 0 1px rgba(0,0,0,0.5);}.toggle-checkbox:checked + .toggle-switch{background:#3e96df;}.toggle-checkbox:checked + .toggle-switch:before{left:30px;}.toggle-checkbox{position:absolute;visibility:hidden;}.toggle-label{margin-left:5px;position:relative;top:2px;}</style></head><body><div id="container"><div id="container"><label class="toggle"><input class="toggle-checkbox" type="checkbox" checked="checked" id="dark-mode-toggle"><div class="toggle-switch"></div><span class="toggle-label">Dark mode</span></label><h1>مقایسه سرعت خوندن/نوشتن RAM و HDD</h1><br />
<h2>چکیده</h2><br />
<p>توی این مقاله به تفصیل راجع به سرعت خوندن/نوشتن اطلاعات روی رم و روی هارددیسک صحبت میکنم، برای این منظور ابتدا تکنولوژی زیر باک رم و زیر باک هارددیسک رو توضیح میدم، بعدش به این موضوع میپردازم که بخاطر پیچیدگی های تکنولوژیک، متوسط سرعت خوندن/نوشتن توی هر کدوم چقدره و با هم مقایسه‌شون میکنم.</p><br />
<h2>چرا میخوایم سرعت رم و هارد دیسک رو مقایسه کنیم؟</h2><br />
<p>RAM vs HDD</p><br />
<p>چند سال پیش توی یه فرومی توی یه تایپیکی مربوط به برنامه‌نویسی من به این نکته اشاره کردم که سرعت خوندن/نوشتن توی هارددیسک بطور متوسط 100 هزار بار از رم کمتره..!<br />
برای بسیاری از برنامه‌نویسها این حرف عجیب بود، و خیلیا قبولش نمیکردن، برای همین من مجبور شدم تکنولوژی هر دو رو توضیح بدم و با زبان تخصصی بگم که چرا چنین حرفی زدم.<br />
با این مقاله همراه باشین تا ببینیم چرا میگم هارد دیسک بطور متوسط صد هزار بار از رم کند تره.</p><br />
<p>اولا که واضحه هیچوقت نمیتونیم همچین چیزیو بطور دقیق بگیم، هر کسی ادعا کنه که مثلاً HDD دقیق انقدر از RAM سریع تره ، معلومه که خیلی چیزارو نمیدونه.</p><br />
<p>دوما ، مقایسه هارد دیسک و رم عمرا توی یک مقاله بگنجه:)<br />
من میتونم یک کتاب چند جلدی راجع به RAM بنویسم و یک کتاب چند جلدی راجع به HDD و توی یک کتاب چند جلدی اینارو با هم مقایسه کنم! نه بخاطر اینکه من خیلی عالم هستم ، بلکه بخاط اینکه متوجه بشین حجم و عمق مطلب خیلی زیاده .<br />
اینجوری نیست که ما بگیم «<em>آره سرعت این موجودیت رو توی اینترنت نوشته انقدر و سرعت اونو نوشته فلانقدر و بقیه‌ش یه تقسیم ساده‌ست،</em>» .....</p><br />
<p>بلکه این مطلب میتونه بعنوان تز دکتری توی تحصیلات عالیه مطرح بشه، و یک نفر پایانامه دکتراشو صرف این کنه و یه مقاله بنویسه، که بازم نمیتونه کل مطلب رو ادا کنه..!</p><br />
<p>اینارو صرفا عرض کردم که بدونین چقدر ماجرای عمیقیه...😬❤️<br />
بیشتر مطالبی که راجع به هارددیسک بیان میکنم رو من چندین سال قبل از کتاب استاد آبراهام سیلورچتس خونده بودم. اسم کتاب هست:</p>
<ul>
<li>Database System Concepts, 6th Edition</li>
</ul><br />
<p>بریم سراغ داستان اصلی.</p><br />
<h2>رم چیست؟</h2><br />
<p>رم – RAM – مخفف Random Access Memory هست یعنی حافظه ای با دسترسی تصادفی، خود این اسم تمام ساختاری که لازم هست راجع به رم بدونیم رو توضیح میده. فرض کنید یه تیکه حافظه گنده دارید که سرعتش نسبتا بالاست (نسبت به تکنولوژیهایی مثل دیسک و ای2پیرام) و شمای انتزاعیش همچین چیزیه:</p><br />
<p><img src="Files/1.png" alt="Abstract RAM schema" /></p><br />
<p><em>مدل انتزاعی یک رم</em></p><br />
<p>هر خونه‌ش رو یک بایت فرض کنید، n تا بایت پشت سر هم که میتونید با سرعت نسبتاً بالا توش اطلاعات رو ذخیره کنید. این سرعت بالا به سیستم عامل این امکان رو میده که جایی داشته باشه که با سرعتی معقول اطلاعات محاسبات فعلیش رو ذخیره سازی کنه.</p><br />
<p>اما چرا سرعتش بالاست؟</p><br />
<p>از لحاظ پیاده‌سازی سخت افزاری، این حافظه روی یه آرایه دو بعدی مدل شده،‌ مثل یه ماتریس. ساختار «Random Access» این امکان رو ایجاد میکنه که ما به تمام خونه های مختلف حافظه در یک زمان یکسان دسترسی داشته باشیم، اما چطور؟<br />
بیاین ساختار بلوک منطقی رم رو نگاه کنیم:</p><br />
<p><img src="Files/2.png" alt="RAM Logical structure" /></p><br />
<p><em>یک رم 8 بیتی - منبع عکس <a href="https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm">ETSU</a></em></p><br />
<p>امروزه رم ها از خونه‌های کوشولویی که توی یه آرایه دو بعدی هستن تشکیل شدن. هر رم یک واحد Address-Decoder داره که آدرسی انکد شده در مبنای 2 (باینری) رو دریافت میکنه و اون رو دیکد میکنه که ببینه کدوم سلول حافظه باید انتخاب بشه (برای خوندن/نوشتن).<br />
توی همین عکس یه واحد منطقی Read/Write داریم که کارش اینه که خبر بده آیا باید چیزی نوشته بشه یا باید چیزی خونده بشه.<br />
همچنین یه واحد دیگه هم وجود داره به اسم Cheap-Select ، این برای موقعی هست که ما بیش از یک چیپ مموری داریم (در واقعیت اینجوریه).<br />
همچنین ساختاری به نام databus وجود داره که توش 0 با ولتاژ پایین و 1 با ولتاژ بالا نشون داده میشه، این قسمت ورودی/خروجی سلول‌های چیپ رم هست.<br />
همچنین فرض کنید سطرهای رم 8 بیتی یا 1 بایتی هستن.</p><br />
<p>فرض کنید شما میخواین توی خونه هزارم (1000) رم بنویسین، برای این حداقل یک آدرس دیکودر 10 بیتی لازم دارین ( چون 2 به توان 10 میشه 1024 و با یک آدرس دیکودر 10 بیتی میشه بین 1024 تا خونه رم تمییز قائل شد و آدرسدهی کرد). حالا شما 1000 در مبنای 10 رو میبرید به مبنای 2 که میشه : 1111101000 <br />
و این عدد آدرس باینری 1111101000 رو میفرستید به آدرس-دیکودر. آدرس-دیکودر با گیتهای منطقی درونی که داره، با گرفتن  1111101000 به عنوان ورودی، سطر هزارم رم رو انتخاب (select) میکنه و خوندن/نوشتن اتفاق می‌افته.<br />
دقیقاً فرقش با یه تکنلوژی مثل دیسک همینه...، توی دیسک باید یکسری خونه پیمایش بشن تا برسیم به خونه مد نظر، اما اینجا یه مدار منطقی داریم که آدرس-دیکودر مدار خاصیش رو روشن میکنه. صرفاً اون مدار انتخاب میشه و نه تنها حرکت فیزیکی نداریم (در مقایسه با دیسک) بلکه پیمایش خونه به خونه هم نداریم (در مقایسه با دیگر تکنولوژیها) <br />
یک آدرس-دیکودر 3 بیتی توی شکل زیر نشون داده شده، حتماً در جریانید که با 3 بیت میشه 2 به توان 3 یعنی 8 حالت مختلف داشته باشیم. پس یه آدرس دیکودر 3 بیتی میتونه 8 خونه از رم رو آدرسدهی کنه و همرو با یک سرعت یکسان انتخاب کنه.</p><br />
<p><img src="Files/3.png" alt="3-bit Address-Decoder" /></p><br />
<p><em>یک آدرس دیکودر 3بیتی با 8 پایانه- منبع عکس <a href="https://codestall.wordpress.com/2017/09/02/532-decoder-design-using-4-38-decoders-and-1-24-decoder-in-verilog/">Codestall</a></em></p><br />
<p>یک آدرس-دیکودر 10 بیتی هم عین همین ساخته میشه، و میتونه 1024 تا سطر مختلف رو انتخاب کنه، فقط شکلش توی این مقاله جا نمیشه:))</p><br />
<p>پس این شد معنی ساختار «دسترسی تصادفی» یا «Random Access»، یعنی زمانی که ما یک طراحی سخت‌افزاری داریم که اوردر زمانی دسترسی به هر سلول حافظه ما با بقیه سلولها برابره، این اتفاق با پیاده‌سازی یه گیت منطقی ممکن میشه که بهش میگیم آدرس-دیکودر و توضیحش دادیم.</p><br />
<p>اگر سرعت دسترسی اینقدر عالی و خوبه، چرا ما RAM رو جایگذین یچیزی مثل دیسک نمیکنیم و ازش استفاده نمیکنیم؟<br />
رم بخاطر ساختار منطقی و الکترونیکی که داره، با قطع شدن جریان برق، تمام اطلاعات داخلش پاک میشه و اصطلاحاً تمام اطلاعاتش ریست میشه(بیتهاش 0 میشه).<br />
این در مقابل دیسک، نمیتونه یه حافظه استیبل برای ذخیره سازی طولانی مدت باشه...، صرفاً برای ذخیره اطلاعات فعلی محدود به محاسبات کامپیوتر خوبه.</p><br />
<p>این روزها حافظه هایی مثل SSD که حرکت فیزیکی ندارن دارن به جای چیزهایی مثل HDD در بعضی جاها استفاده میشن – اونا بخاطر نداشتن حرکت فیزیکی بسیار سریع ترن – اما مشکلات خودشونم دارن. شاید در آینده توی یه مقاله جدا اون تکنولوژیهارو هم بررسی کردیم.</p><br />
<p>برگردیم به رم، از لحاظ تکنولوژی ساخت رم ها به دو دسته استاتیک و داینامیک تقسیم میشن.</p>
<ul>
<li>رمهای استاتیک (SRAM):</li>
</ul><br />
<p>رمهای استاتیک اطلاعات رو توی مدارهای ترانزیستوری شبیه D-فلیپ فلاپ ذخیره میکنن، و این اطلاعات مادامی که رم برق داشته باشه اونجا میمونن و از بین نخواهند رفت. نسبت به رم های داینامیک کوشولوتر هستن و سرعتشون بیشتره و دیکودر ساده‌تری دارن. معمولاً توی فرایندهای سرعتی مثل کش کردن و اپلیکیشنهای خیلی سریع استفاده میشن.<br />
بعضی جاها که میخوان اطلاعات مهم رو روی رم نگه دارن، از همین SRAM استفاده میکنن و یه باتری بک‌آپ به مدار اضافه میکنن که حتی اگه به هر دلیلی برق مدار قطع شد، باتری سیستم رو تغذیه کنه و اطلاعات پاک نشه.</p>
<ul>
<li>رمهای داینامیک (DRAM):</li>
</ul><br />
<p>رمهای داینامیک اطلاعات رو رو خازنها ذخیره میکنن. این خازنها بخاطر ساختار کوشولوتری که دارن ظرفیت کلی رم رو میرن بالا، اما این خازنها یه مشکل بزرگ دارن، هر خازن طبق طبیعت الکترونیکش بعد از مدت زمانی جریان داخلی خودش رو از دست میده و اصطلاحاً دِشارژ میشه. بعد از  دِشارژ شدن یه خازن اطلاعاتی هم که توش ذخیره شده بوده میپره! به این روند میگن leak شدن جریان برق. برای جلوگیری از - از دست رفتن اطلاعات، باید تند-تند اطاعات کل خازنها خونده بشن و دوباره همونجا نوشته بشن که خازنها شارژ بمونن و اطلاعات از دست نره. به این روند میگن refresh کردن مدار. پس توی DRAM ها باید یه مدار ریفرش-کننده باشه که اطلاعات همه خازنهارو هی تند-تند بخونه و هی تند-تند دوباره سر جاشون بنویسه.<br />
ضمناً رمهای داینامیک خیلی از رمهای اساتیک ارزونتر هستن، و رمهایی که روی سیستم شما الان دارن استفاده میشن احتمالاً دینامیک هستن.</p><br />
<p>بهتون پیشنهاد میکنم مصاحبه استیو ووزنیاک رو حتماً مطالعه کنین، این مصاحبه علیرغم اینکه قرار بوده مصاحبه محاوره ای و معمولی نسبت به خودش شخص ووز باشه، توش بینهایت توضیحات تخصصی الکترونیکی داره..!<br />
یه قسمتش راجع به تکنولوژی رمها حرف میزنه که خیلی جالبه:</p><br />
<p><em>«...به اطرافم نگاه کردم، اولین رم دینامیک همون سال معرفی شده بود. 1975 اولین رم دینامیک 4کلیوبایتی به بازار اومده بود. این اولین بار بود که قیمت رم از قیمت حافظه‌های مغناطیسی، که تا امروز در همه جا استفاده میشد کمتر بود. حالا ناگهان دنیا داشت به سمت رم میرفت، حافظه ما از این به بعد روی سیلیکون بود. تقریبا همه در جهان، آلتیر – شفر کامپیوتر – پلیمرفیک کامپیوتر – اینسایت کامپیوتر و ...، با مهندسهایی ناکارآمد و نه بهترین مهندس های موجود طراحی میکردن. اونها تکنسینهایی بودن که میدونستن باید چطور دیتاشیت رمهارو بخونن و بعد توی دیتاشیت ریزپردازنده‌ها دنبال خطی بگردن که توش نوشته شده آدرس، و اونو با آدرس رم تطبیق بدن و سیمکشی کنن. این کار ساده ایه، اما فقط در صورتی کار میکنه که رمهای شما استاتیک باشن. رمهای دینامیک قیمتی برابر نصف یا حتی یک چهارم قبلیا داشتن. معنی رم دینامیک این بود که به جای داشتن 32 تراشه برای ساخت کامپیوتری که زبون بفهمه، میتونستین 8 تراشه رم داشته باشین. اما رم دینامیک به مدارهایی نیاز داشت که در هر ثانیه 2000 بار به تک تک آدرسهاشون سر بزنن و چیزی که اونجاست رو بخونن و دوباره اونارو همونجا بنویسن تا اطلاعات از دست نره! رم دینامیک که امروز هم در کامپیوتر ما وجود داره هر بیتی رو فقط در دوهزارم ثانیه فراموش میکنه مگر اینکه یه نفر اون بیت رو توی این زمان بخونه و دوباره سر جاش بنویسه. میشه اینطور گفت که الکترون ها توی بشقابین که در هر 2هزارم ثانیه ازش میریزن بیرون..!»</em></p><br />
<p>ترجمه از استاد جادی، کل مصاحبه به زبان فارسی:<br />
<a href="https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90">https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90</a></p><br />
<p>اصل مصاحبه:<br />
<a href="http://www.foundersatwork.com/steve-wozniak.html">http://www.foundersatwork.com/steve-wozniak.html</a></p><br />
<p>و دیگه تقریباً تمام مسائل تکنیکی که میخواستم راجع به رمها بگم رو گفتم، مدیریت یک رم بر عهده سیستم عامله. CPU کامپیوتر با Virtual-Addressing کار میکنه و خود رم با Logical-Addressing. <br />
بعداً یه مقاله جدا راجع به اینکه سیستم عامل چه‌جوری رم رو به پراسسها تخصیص میده مینویسم و یه مقاله جدا هم مینویسم راجع به اینکه چطور میتونیم به کل رم فعلی سیستم دسترسی داشته باشیم.</p><br />
<h2>هارددیسک چیست؟</h2><br />
<p>دیسکها، لوحهای گرد و دایره‌ای شکلی هستن که میتونن بسته به معماریشون اطلاعات رو توی خودشون ذخیره کنن، اولین نوع دیسکهارو میتونیم توی گرامافونها ببینیم، که اونجا صدای ورودی به گرامافون باعث ایجاد لرزه میشد و سوزن روی لوح گردی که میچرخید یه شیاری رو بصورت حلزونی ایجاد میکرد. برای پخش صدا سوزن نرم تری میذاشتن که توی شیار حرکت میکرد و با استفاده از لرزش صدارو بازپخش میکرد.<br />
بعدها دیسکهای سخت مغناطیسی اومدن که ازشون میخوایم حرف بزنیم و همینطور دیسکهای نوری مثل CD ها و DVDهارو داشتیم که با یک لیزر توشون اطلاعات burn میشد.<br />
پس دیسک به طور کلی توی این حوزه،‌ معمولا لوح گردی هست که حول یه محوی میچرخه و اطلاعات توی شعاع های مختلف اون نوشته میشه.</p><br />
<p>یه هارددیسک، شامل دیسکهای گرد مغناطیسی هست که اطلاعات توش با مغناطیسه شدن هر ذره کوشولو از دیسک، بصورت باینری نوشته میشه. هارددیسک معمولا از چند تا لایه (پلاتر-platter) تشکیل شده، تعداد این پلاتر ها معمولا بین 1 تا 5 تا هست.<br />
اگه بصورت یه برش عرضی ببینیم این شکلی میشه:</p><br />
<p><img src="Files/4.jpg" alt="HDD Platters" /></p><br />
<p><em>منبع عکس <a href="https://www.compuclever.com/posts/hard-disk-drive-basics/ic306536/">compuclever</a></em></p><br />
<p>همون برش عرضی بصورت انتزاعی:</p><br />
<p><img src="Files/5.jpg" alt="HDD Abstract Platters" /></p><br />
<p><em>منبع عکس: کتاب Database System Concepts, 6th Edition</em></p><br />
<p>حالا این پلاتر ها، یه سطح مغناطیسی هستن که میتونن با مغناطیسه شدن، 0 و 1 هارو توی خودشون ذخیره کنن.<br />
این پلاتر، به شکل منطقی (logical) به یسری شعاع های متفاوت تقسیم میشه، که این شعاعها شامل دایره‌های گردی هستن که دیسک رو میسازن، به هر کدوم از این شعاع ها میگن یه ترک- Track<br />
توی عکس زیر چندین ترک انتزاعی رو میبینید:</p><br />
<p><img src="Files/6.jpg" alt="HDD Tracks" /></p><br />
<p><em>منبع عکس <a href="https://www.schoolcoders.com/memory-storage/secondary-storage/hdd/">schoolcoders</a></em></p><br />
<p>خود این ترک به قسمتهای کوچکتری تقسیم میشه، که بهش میگن سکتور- sector<br />
توی عکس زیر قسمت سکتور رو مشاهده میکنید:</p><br />
<p><img src="Files/7.jpg" alt="HDD Sectors" /></p><br />
<p><em>منبع عکس <a href="https://slideplayer.com/slide/1517076/">slideplayer</a></em></p><br />
<p>یه سکتور کوچکترین واحدی توی دیسک هست که نوشته/خونده میشه، معمولا سایز یه سکتور 512 بایت هست...</p><br />
<p>یه دسته‌ای هم توی یه هارددیسک وجود داره که بهش میگن arm که سرش یه هد (head) داره که عقب جلو میره و خود دسته هه هم میچرخه و این سکتورهارو میخونه یا توشن مینویسه.</p><br />
<p>منطقا ترکهای بیرونی(شعاع های بزرگتر) تعداد سکتورهای بیشتری از ترکهای درونی(شعاعهای کویچکتر) دارن..</p><br />
<p>هر نوع اطلاعاتی که بخواد روی دیسک نوشته بشه، باید بصورت 0 و 1 نوشته بشه، یعنی بصورت باینری انکد بشه، و به آرم  داده بشه که توسط هد توش نوشته بشه. همین داستان برای خوندن هم بر قراره.<br />
بسته به فرمتهای مختلف نرم افزاری که هارددیسکهارو با اونها فرمت میکنیم، یکسری تکنولوژی نرم‌افزاری وجود دارن که مربوط به بحث ذخیره سازی داده‌ها هستن مثل inode و mft که بعداً توی مقالات دیگه راجع بهشون حرف میزنیم.</p><br />
<h2>مقایسه سرعت هارددیسک و رم</h2><br />
<p>فرض کنید تمام پیچیدگی های پیاده سازی و عملیاتی و سیستم عاملی رم رو نادیده بگیریم ، و یه راست بریم سراغ هارد دیسک:</p><br />
<p>وقتی سرعت یک هارد دیسک رو میخوایم در نظر بگیریم ، باید سرعت متوسط اعمال I/O رو توی اون در نظر بگیریم یعنی ورودی خروجی های هارد دیسک<br />
*Input/Output<br />
یا به زبان فارسی ساده : خوندنها و نوشتن‌ها</p><br />
<p>محاسبه این سرعت بشدت کار تخصصی هست و توی این سرعت هزاران فاکتور دخیله، فاکتور هایی که هر کدوم توضیح دادنشون یک کتابه مطلبه و نهایتا اگر تمام فاکتور هارو بتونیم مدلسازی کنیم ، (که خیلی کار سختیه) در سناریو های مختلف ممکنه از 10 هزاربار تا مثلا 500 هزار بار کند تر عمل کنه. که متوسط این سناریو هارو بعنوان آمار بیان میکنن.</p><br />
<p>یک هارد دیسک ، مثل یک CD یه (چند تا) دیسک داره که میچرخه و یک هد داره (مثل اون دسته سیاهای توی گرامافون) که روی یه مداری که روی شعاع دیسک واقع شده میتونه بالا و پایین بره. به این ترتیب میتونه تمام دیسک رو پردازش کنه.</p><br />
<p>گیف پایین رو مشاهده بفرمائید:</p><br />
<p><img src="Files/8.gif" alt="HDD head move" /></p><br />
<p><em>یادم نمیاد منبع گیف کجاست- اگر میدونید خبر بدین!</em></p><br />
<hr /><br />
<p>یک سرعتی برای هارد دیسک بیان میشه بعنوان Transfer time که مجموعه کلی‌ای از چند تا سرعت هست وابسته به فاکتور های زیر :</p><br />
<p>1 - سرعت خوندن هد {سرعت خوندن دیتا توسط هد ، باز خودش وابسته هست به 7-8 تا فاکتور! ما میگیم که متفاوته و ریزتر نمیشیم}</p><br />
<p>2 - سرعت بالا و پایین شدن هد</p><br />
<p>3 - سرعت چرخش دیسک {در هارد دیسکهای متفاوت‌، این سرعت متفاوت هست}</p><br />
<p>4 - ظرفیت ترک (track)</p><br />
<p>5 - ظرفیت سکتور</p><br />
<p>6 - مقدار دیتای طلب شده</p><br />
<p>7 - تاخیر چرخشی (این با سرعت چرخش فرفق میکنه ) بهش میگن Rotational Latency<br />
(من یکمی توی همین مقاله توضیحش میدم ولی خیلی بیشتر از این مطلب لازم داره، توی کتابی که معرفی کردم خیلی خوب توضیح داده)</p><br />
<p>8 - تاخیر seek کردن هد یا seek time<br />
( اینم جلوتر من یکمی توضیحش میدم )</p><br />
<p>9 - بلاک اینترلیود بودن هارد دیسک (اینو بعدش توضیح میدم و میگم که چه فرقی با رم داره که رم بایت اینترلیود هست - این خیلی جالبه) </p><br />
<p>10 - تکنیک جلو-جلو خوندن هارددیسک یا read ahead <br />
(اینم باید توضیح بدم)</p><br />
<p>11 - ظرفیت اتخاذ شده برای تکنیک بافرینگ Buffering. <br />
(اینم باید توضیح بدم)</p><br />
<p>12 - الگوریتمهای زمانبندی روی هارد دیسک! این مطلب خودش میتونه یه کتاب 12 جلدی باشه! من واقعا نمیدونم چجوری میتونم حق مطلب رو توی این مقاله ساده بیان کنم! زبان من الکن هست از توصیفش - مثلا من اگه میشد الگوریتم آسانسورو برای شما شرح بدم که ببینین اگر نبود هارددیسک یک ملیارد بار کند تر میشد...!</p><br />
<p>13 - نحوه چینش فایلها!!! این دیگه واقعا خیلی خییلی خیلی خیلی توضیح میطلبه!!! شما قطعا از فرگمنت شدن دیسک اسمشو شنیدین ، شاید فقط شنیدین که دیسک دیفرگ بشه سرعتش میره بالا... شایدم میدونین معنیش چیه... حالا توضیحش میدیم😬</p><br />
<p>14 - نحوه ذخیره سازی لاگها روی هارد دیسک - که من راجع بهش چیزی نمیگم</p><br />
<p>15 - کش کردن درخواستها توسط سیستم عامل که از اسکیل بحث ما خارجه</p><br />
<p>16 - بحث دیوایس منیجینگ یا به قول ویندوزی ها درایو منیجینگ که بشدت تخصصیه و کار من نیست توضیحش</p><br />
<p>17 - ... انقدر فاکتور در این سرعت دخیل هست که من اگه بخوام بگم شاید هیچوقت نتونم این مقاله رو ببندم، همه بحثهاشم من بلد نیستم* بسیار بسیار تخصصی هست ، باید مراجعه کنید به خبره های فایل سیستم، من اطلاعات خیلی ناکامل محدود و اندکی دارم.</p><br />
<p>حالا زمان اتقال یا ترنسفر تایم، - که اول گفتم - میشه جمعِ تمــــــام این تاخیر ها و زمانهای موجود!</p><br />
<hr /><br />
<p>حالا بریم سراغ توضیح قسمتهایی که گفتم، شروع کنیم از توضیح دو مورد اول که خیییلی باحال و مهمه:</p><br />
<p>رم مستقل از حرکات فیزیکیه اما هارددیسکها اتلاف زمان/انرژی توی حرکت فیزیکی دارن. </p><br />
<p>دو اتلاف وقت مشهور فیزیکی در هارددیسک: </p><br />
<p>1 - هارد دیسکها یه اتلاف دارن موقع چرخیدن خود دیسک 💿<br />
مثلا یه داده ای که میخوای بخونی یا بنویسی ، توی این درجه از دیسک نیست(درجه ای که هد روی اون قرار داره) و مثلاً دیسک باید 260 درجه بچرخه تا توی اون درجه بخصوص بیفتته!<br />
بهش میگن:</p>
<ul>
<li>rotational latency time</li>
</ul><br />
<p>2 - یک اتلاف وقت دیگه دارن اینکه اون سیخسیخک هارد که بهش میگن هد (head) باید بالا و پایین بره و دقیق روی شعاع مربوطه بیفته تا بتونه سکتورو پیدا کنه ، بهش میکن زمان بالا پایین شدن برای جستجو یا </p>
<ul>
<li>seek time</li>
</ul><br />
<p>همین دوتا حرکت فیزیکی کافیه تا هارد دیسک بشدت کند باشه و نشه ازش بجای یچیزی مثل رم جهت ذخیره‌سازی سریع اطلاعات محاسبات فعلی استفاده کرد، ولی خوبیش اینه که اطلاعات با قطع شدن برق از بین نمیرن:3</p><br />
<p>عکس زیرو ببینین:</p><br />
<p><img src="Files/9.jpg" alt="seek-time vs rotational-latency-time" /></p><br />
<p><em>یادم نمیاد منبع این عکس هم کجاست- اگر میدونید خبر بدین!</em></p><br />
<p>راستیه روتیشنال لیتنسی تایمه،<br />
زمانی که دیسک باید بیکار وایسته تا دیسک بچرخه و اول سکتور مورد نظر بیاد.</p><br />
<p>چپیه سیک-تایمه،<br />
زمانی که باید هد حرکت کنه بره روی شعاعی که سکتور مورد نظر هست.</p><br />
<hr /><br />
<p><strong>بلاک اینترلیود بودن هارد دیسک:</strong></p><br />
<p>ما چند نوع اینترلیوینگ (معماری کار با بخشی از داده) داریم :</p>
<ul>
<li>معماری bit-interleaved:
یعنی که اطلاعات بیت بیت از یک حافظه ای خونده بشه</li>
<li>معماری byte-interleaved:
یعنی که اطلاعات بایت بایت از یک حافظه ای خونده بشه</li>
<li>معماری block-interleaved:
یعنی که اطلاعات بصورت چانکهایی که 1 بلاکه هست از هارد دیسک خونده بشه - سایز این بلاک رو سیستم عاملها مشخص میکنن.</li>
</ul><br />
<p>حالا فرقش چیه؟<br />
قدیما اون اوایل که کامپیوتر ساخته شده بود میومدن یه بیت یه بیت میخوندن اطلاعاتو ، طبیعیه که خیلی کار بیخودیه ، چون تمام اطلاعاتی که ما باهاشون کار میکنیم حداقل یه بایت میطلبن<br />
پس معماری بایت اینترلیود مطرحش شد و به کار گرفته شد…</p><br />
<p>امروزه شما نمیتونی یه بیت اطلاعات بنویسی توی دیسک یا روی رم یا تقریبا هر حافظه ای، باید حد اقل یک بایت بنویسی،<br />
مثلا واسه یه متغیر بولین (TRUE/FALSE) فقط یه بیت کافیه ، اما همیشه 8 بیت میگیرن ، چونکه جنس حافظه بایت اینترلیود هست:)</p><br />
<p>حالا توی هارد دیسکها اومدن بلاک اینترلیود بودنو مطرح کردن ، وقتی طرف یه سیستم-کال میزنه به هارد دیسک و میگه که فلان بایت رو به من بده ، هارد دیسک میگه که من این همه دیسک بچرخونم هد بالا پایین کنم واسه یه بایت ؟! خب اگه بر فرض تو بعدش بگی بایت بعدیشم بده ، من دوباره باید برم هی دیسکو بچرخونم بایت بعدیشو پیدا کنم؟!<br />
من مسخره تو نیستم! یه بلاک داده بهت میدم ، تو هر چقدرشو نیاز داری واکشی کن ، اگه بیشترم میخوای که بوگو!<br />
مثلا 1024 بایت میده به سیستم عامل ، حالا سیستم عامل خودش فقط بایت اولشو میخواد ، میکشه بیرون و بقیه رو میریزه دور...<br />
این قضیه الکی نیست ، روش 20 سال فکر شده و هزاران نفر آزمایش کردن و فهمیدن بلاک اینترلیود بودن بهتره از بایت اینتر لیود بودن برای HDD ها</p><br />
<p>حالا قضیه اینطوریه که رم byte-interleaved هست و هارددیسک block-interleaved</p><br />
<p>این قضیه خودش یک دنیا سرعتو HDD رو از رم کندتر میکنه در مقایسه.</p><br />
<hr /><br />
<p><strong>تکنیک جلو-جلو خوندن هارددیسک یا read ahead :</strong></p><br />
<p>این تقریبا یه مفهومی شبیه چیزی که الان قبلش توضیح دادم داره ولی یه دنیا متفاوته!</p><br />
<p>مثلا هارد دیسک بر اساس رفتار میفهمه که سکتور هایی که پیاپی هستن، ممکنه نیازمند کاربر (سیستم عامل ) بشن، پس درسته که سیستم عامل نگفته که اون عداد بلاک رو به من برسون، ولی هارد دیسک میرسونه، که اگه به کارش اومد، دوباره نخواد سیستم کال بزنه و دستوراتش بره واسه درایور سخت افزار، و موتور هارد دیسک روشن بشه ، و بره جدول ذخیره سازیو دوباره بخونه، شماره سکتورو بفهمه بچرخونه و هد رو بالا پایین کنه ، و بطور مغناطیسی بخونه و برگردونه و......🥴<br />
این الگوریتمهاش پیچیده هستن، میشه راجع بهش هزاران آزمایش کرد و هزاران الگوریتم ارائه داد...</p><br />
<hr /><br />
<p><strong>ظرفیت اتخاذ شده برای تکنیک بافرینگ Buffering:</strong></p><br />
<p>بافر در علم کامپیوتر یعنی یه حافظه موقت.<br />
اینکه بافرینگ HDD چیه ، واضحه یه تیکه حافظه توی رمه که اطلاعاتی که از هارددیسک واکشی شده و اومده توش نشسته تا یه فکری به حالش گرفته بشه.<br />
اما این ظرفیت بافر کردنه خیلی متفاوته در سیستم عاملها، همین ظرفیت سرعت رو خیلی متاثر خودش میکنه...<br />
من بیشتر از این واردش نمیشم ، از اساتید سیستم عامل باید سوال بشه :3</p><br />
<hr /><br />
<p><strong>الگوریتمهای زمانبندی روی هارددیسک:</strong></p><br />
<p>بعضیها تصورشون اینه که در هر لحظه فقط یک عمل I/O برای هارد دیسک میره،<br />
ولی فی الواقع ، در هر لحظه که با هارد دیسک تراکنش داریم ، هزاران هزار درخواست میره که بعضی هاشون درخواست نوشتن هستن و بعضی هاشون درخواست خوندن...</p><br />
<p>هارد دیسکها فقط یه هد دارن و یه دیسک ( اون سه لایه ها مد نظر ما نیست - اونا هر کدوم یه هارد دیسک حساب میشن ) وقتی یه هد داریم و یک دیسک طبیعیه که باید اسکجولینگ خیلی خفنی پیاده کنیم، تا بتونیم درخواست های داده شده رو کاملا ارضا کنیم.</p><br />
<p>اسکجولینگ خیلی خیلی مبحث پیچیده ای هست ، جدیا از بحث های سیستم عاملیش و نرم افزاریش، باید الگوریتم های سخت افزاری خفنی داشته باشیم تا بتونیم حرکاتمونو بیشتر بهینه کنیم.</p><br />
<p>مثلا الگوریتمی وجود داره به اسم الویتور یا آسانسور، که میگه که حالا که دیسک داره میچرخه و روی این سکتور ها هستی، این بلاکم بده مال درخواست سوممونه تا برسیم به سکتور درخواست اول - یا اینکه حالا که داریم اینوری سیک میکنیم روی هد همینو سیسک کن و برنگرد عقب که ادامه رو بخونی ، همونو ادامه بده درخواست پنجم روی اون نواره ، بعدا موقع برگشت دستور اولم میخونیم.</p><br />
<p>مثل یک اسانسوری که داره میره بالا و طبقه 16 عه داره میره طبقه 20 ، یکی که طبقه 1 باشه دکمه رو بزنه نمیاد پایین سوارش کنه و بعدا بره 20! میره طرف 20 رو سروار میکنه بعدا میاد 1 - اینو وسط یکی طبقه 2 هم باشه سوارش میکنه.<br />
راجع به آسانسور به تنهایی میشه کتاب نوشت …:))</p><br />
<p>هزاران الگوریتم دیگه وجود دارن!<br />
یک بحث بهینه‌سازی خیلی شاخی داره<em>-</em></p><br />
<p>که اگه این بحثها نبودن واسه یه I/O زدن روی دیسک باید 70 سال منتظر مینشستیم.</p><br />
<hr /><br />
<p><strong>نحوه چینش فایلها (داده ها):</strong></p><br />
<p>این شاید مهم ترین بحثه ...<br />
هیچوقت نمیشه از دیسک بعنوان مموری پردازشی استفاده کرد‌، چون نحوه چینش داده هاش خیلی خیلی سخته...</p><br />
<p><em>یه مقاله هم راجع به ریکاوری مینویسم؛ اونجا فرگمنت شدن دیسک رو توضیح میدم</em></p><br />
<p>دیسک فرگمنت شده:</p><br />
<p><img src="Files/10.jpg" alt="Fragmented HDD" /></p><br />
<p>خلاصه که همیشه سرعت هایی که بر آورد میکنید باید بر اساس یک دیسک فرگمنت شده باشه ، که خودش هزاران بار ماجرا رو کندتر میکنه،<br />
توی RAM ما فرگمنت شدن نداریم یعنی داریم؛ ولی روی سرعت به اون شکل تاثیر نداره - اصلا بیس کارش فرگمنت بودنه، رم همونطور که توضیح دادم به تمام خونه های خودش به یک زمان مساوی «دسترسی تصادفی» دسترسی داره.</p><br />
<p>خوندن اطلاعات و کار کردن با جداول روی هارددیسک (چیزهایی مثل inode یا mft) کار خیــــلی ریسورس-بر و زمان بریه.</p><br />
<p>پس خلاصه ماجرا این میشه که،<br />
ترنسفر تایم هارددیسک که از مجموع همه مواردی که گفتم + هزار مورد مطلب دیگه تاثیر میپذیره، خیلی کند هست.<br />
حرکت فیزیکی دیسک بقدری کند هست که با چشم قابل دیدنه !</p><br />
<p>توی رم معماری با گیت منطقی پیاده شده و سرعتش وابسته به سرعت حرکت جریان (الکترون آزاد) هست.</p><br />
<p>یه کلیپم دارم که یک کپی پبیست ساده در هارد دیسک رو بصورت اسلوموشن نشون میده،<br />
حرکات فیزیکی هارددیسک، وقتی درش رو باز میکنیم و میبینیم😬:</p><br />
<p><a href="https://www.youtube.com/watch?v=3owqvmMf6No">https://www.youtube.com/watch?v=3owqvmMf6No</a></p><br />
<p>حرکتی که با چشم قابل دیدن هست و بار دوربین قابل ظبط، قطعا خیلی کند تر از سرعت حرکت الکترونهاست:)<br />
و در کل، بطور متوسط 100 هزاربار کندتر بودن کاملا منطقی هست، اما بیاین با دانش برنامه‌نویسی که داریم، خودمون هم دست به آچار بشیم و تست کنیم ببینیم در عمل جریان چجوریه!</p><br />
<hr /><br />
<p>میخوایم یکسری برنامه بنویسیم که ادعایی که کردیم (کند تر بودن هارد دیسک از رم به میزان 100 هزار بار) رو تست کنیم.</p><br />
<p>زبان برنامه‌نویسی مورد علاقه من <code>PHP</code> هست، اما وقتی بحث سنجش پیچیدگی زمانی/ریسورسی الگوریتمها میاد وسط و میخوایم آزمایشهایی رو راجع به مقایسه زمان/ریسورس مصرفی متدهای مختلف انجام بدیم، من نظرم اینه که همیشه باید حدالقمدور از زبانهای برنامه‌نویسی نزدیک به سطح پایینتر استفاده کنیم. زبانهایی کامپایلری مثل <code>C</code> و <code>C++</code> همیشه به ما دسترسی بسیار بیشتر،‌ نزدیکتر و بهینه‌تری به ریسورسهایی مثل رم و دیسک میدن و همچنین بخاطر ساختار کامپایلری‌شون، کدی ترجمه شده به زبان ماشین میدن که صرفاً نقش اجرای الگوریتم رو بر عهده داره و خیلی کمتر درگیر محاسبات پرت میشن. با استفاده از این زبانها، نتیجه آزمایشهای ما متأثر از زمان/ریسورس پرتی که صرف تفسیر کد یا اجرای فرایندهای اجرایی مفسر و مترجم و کامپایلر هست نمیشه. برای همین توی این آزمایشمون از زبان <code>C++</code> استفاده میکنیم.</p><br />
<p>کد زیر رو در نظر بگیرید:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_write_test.cpp">فایل کد</a></p><br />
<p>این قطعه کد زمان اجرا و میزان رم مصرفی مربوط به یک قطعه کد خاص رو اندازه‌گیری میکنه، اون قطعه کد خاص، سگمنت زیر هست که به اندازه دقیقاً 1 گیگابایت (1073741824 بایت) فضای رم رو تخصیص میده به یک آرایه از نوع کرکتر، اگه بخوام به زبان ساده بگم این قطعه کد که میبینید، دقیقاً 1 گیگابایت اطلاعات رو روی رم ذخیره میکنه:</p>
<pre><code class="language-cpp">char* arr = new char[1073741824];
for(int i = 0; i &lt; 1073741824 ; i++)
    arr[i] = 'A';</code></pre><br />
<p>با اجرای این کد، میتونیم با یه تقریب خوبی بسنجیم که ذخیره کردن 1 گیگابایت از اطلاعات روی مموری بصورت دسترسی تصادفی (Random Access) چه مقدار زمانی طول میکشه و اینکه چقدر از مموری (RAM) استفاده میشه (منطقاً دقیقاً باید 1 گیگابایت استفاده بشه). این کد کزمان اجرای اون قطعه سگمنت مذکور رو یک بار با اساتفاده از کلاکها توی کتابخونه ctime میسنجه و بار دیگر با استفاده از کتابخونه chrono. بدین ترتیب ما میتونیم بگیرم زمان خروجی ما نسبتا دقیق هست، یادتون باشه که اینکلود کردن iostream توی این کامپایلر من خودش کتابخونه ctime رو هم به کد اضافه میکنه، اگه توی کامپایلر شما این قضه کار نکرد، حتما کتابخونه رو دستی اینکلود کنین:</p><br />
<p><code>#include &lt;ctime&gt;</code></p><br />
<p>بیاین کد رو اجرا کنیم تا ببینیم پاسخ چیه، من روی یه ماشین لینوکس هستم، پس کد رو با <code>g++ RAM_test.cpp</code> کامپایل میکنم و با <code>./a.out</code> اجرا میکنم.</p><br />
<p>نکته: همیـــشه یادتون باشه که در اینجور آزمایشها و مقایسه ها، انجام آزمایش (اجرای کد) رو حداقل 3 بار در شرایط مختلف تکرار کنید و متوسط کلی رو بعنوان پاسخ در نظر بگیرید، در هر لحظه توی یک ماشین کامپیوتری هزارن پراسس دیگر وجود دارن که با ریسورسها در حال تعامل هستن، رفتار این پراسس ها ممکنه در زمانهای متفاوت، تأثیری روی نتیجه آزمایش شما هم بذاره.</p><br />
<p>نکته2: یه دستور معروف یونیکسی هست به اسم <code>time</code> که با اون میتونیم یسکری اطلاعات جانبی راجع به کامندی که ران میکنیم داشته باشیم. من از این پکیج استفاده میکنم که زمانها و سی‌پی‌یو مصرفی حین اجرای برنامه رو مانیتور کنم. بعد از اجرا دقیقاً توضیح میدم معنی این اطلاعات چیه.</p><br />
<p>اجرای کد:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_write_test.cpp 

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out 
Execution Time (Based on ctime): 2501.88 ms
Execution Time (Based on chrono): 2501.97 ms
Memory Usage: 1046800 KB

real    2.51s
user    2.36s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2440.13 ms
Execution Time (Based on chrono): 2440.23 ms
Memory Usage: 1046864 KB

real    2.45s
user    2.32s
sys     0.13s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2446.16 ms
Execution Time (Based on chrono): 2446.23 ms
Memory Usage: 1046772 KB

real    2.45s
user    2.32s
sys     0.13s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2444.35 ms
Execution Time (Based on chrono): 2444.5 ms
Memory Usage: 1046848 KB

real    2.45s
user    2.29s
sys     0.16s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2515.03 ms
Execution Time (Based on chrono): 2515.09 ms
Memory Usage: 1046832 KB

real    2.52s
user    2.39s
sys     0.13s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2438.22 ms
Execution Time (Based on chrono): 2438.28 ms
Memory Usage: 1046844 KB

real    2.45s
user    2.32s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2493.81 ms
Execution Time (Based on chrono): 2493.94 ms
Memory Usage: 1046784 KB

real    2.50s
user    2.35s
sys     0.15s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2501.99 ms
Execution Time (Based on chrono): 2502.09 ms
Memory Usage: 1046852 KB

real    2.51s
user    2.37s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2459.47 ms
Execution Time (Based on chrono): 2460.05 ms
Memory Usage: 1046872 KB

real    2.47s
user    2.32s
sys     0.15s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2429.63 ms
Execution Time (Based on chrono): 2429.75 ms
Memory Usage: 1046772 KB

real    2.43s
user    2.32s
sys     0.12s
cpu     99%
</code></pre><br />
<p>من این کد رو توی 10 بازه زمانی مختلف که سیستم من هر بار درگیر محاسبات متفاوتی بود اجرا کردم و خروجی به شرح بالا بود، همونطور که میبینید زمان اجرا با یه تقریب خاصی در یک رنجه، اما هر بار تغییرات جزئی داره که این نتیجه کارکردهای پارلل سیستم عامل ما هست، بعداً راجع به محاسبات موازی سیستم عامل یه مقاله مینویسم، اما مساله جالب دیگه اینه که میزان مموری مصرفی هم توی هر بار اجرا متفاوت بوده و این کمی عجیب بنظر میرسه… اما میشه تخصصی بررسیش کرد و اون موقع میبینیم که کاملاً معقوله. بررسی تخصصیش از حوصله این مقاله خارجه اما، بطور خیلی خلاصه میتونیم بگیم که کارکرد کد به کارکرد کتابخونه‌ها و توابعی که از سیستم اینکلود کردیم وابسته هست، این توابعی که کال کردیم هر بار اون زیر باک سیستم عامل دیتاهای متفاوتی رو وارد رم میکنن، و همین باعث متفاوت شدن میزان دیتای نشسته روی رم میشه، اما در کل روی رنج 1 گیگابایتی هست که سگمنت مذکور ما مصرف میکنه.</p><br />
<p>و حالا بریم سراغ توضیحات تخصصی کامند تایم که شامل ریپورتهایی از قبیل real و user و sys و cpu هست و ببینیم اینا چه معنی میدن. </p><br />
<p><strong>زمان Real</strong></p><br />
<p>کل زمانی که طول کشیده که پراسس شروع بشه و به اتمام برسه، انگار که با یه کرنومتر بسنجیمش. به زبان تخصصی این زمان شامل همه زمانها میشه، زمان محاسبات و زمانهایی که پراسس منتظر میمونده (بلاک بوده) و زمانهایی که منتظر I/O بوده.</p><br />
<p><strong>زمان User</strong></p><br />
<p>زمانی هست که سی‌پی‌یو صرف محاسبات برنامه میکنه، و به زبان تخصصی زمانی هست که پراسس روی سی‌پی‌یو نشسته و داره اجرا میشه (بهش میگن user-mode)</p><br />
<p><strong>زمان Sys</strong></p><br />
<p>زمانی هست که سی‌پی‌یو مشغول تسکهایی بوده که کرنل سیستم عامل بخاطر پراسس داشته انجام میداده، مثلاً مموری الوکیشن و I/O ها… (به این قسمت میگن kernel-mode)</p><br />
<p>به دو حالت اجرای پراسس ها روی پردازنده اشاره کردم به اسامی یوزر-مود و کرنل-مود. اینا مودهای اجرای برنامه توی سیستمهای یونیکسی یا هر سیستم مموری-پروتکتد دیگری هستن. بین یوزر-مود و کرنل-مود تفاوتهایی وجود داره که من سعی میکنم خیلی خیلی خلاصه توضیح بدم و بعدش منبع بدم که توضیحات تخصصی‌تر و مفصل رو از اونجا مطالعه بفرمائین:</p><br />
<p><strong>کرنل-مد/Kernel-mode</strong></p><br />
<p>اگه کدی توی این حالت اجرا بشه، اون قطعه کد دسترسی کامل و بدون محدودیتی به سخت‌افزار داره. میتونه هر سیستم کالی رو اجرا کنه، مثل هر اینستراکشنی برای CPU یا تعامل با هر قسمت رم. این بالاترین سطح دسترسیه و در پایین‌ترین لایه اتفاق می‌افته. اگه توی کدهای اجرایی این لایه خرابکاری یا اشکالی پیش بیاد خطرناکه و کل سیستم رو به مخاطره میندازه برای همین کدها و فانکشنهای معتمد سیستم عامل توی این حالت اجرا میشن.</p><br />
<p><strong>یوزر-مد/User-mode</strong></p><br />
<p>توی این حالت بر عکس حالت قبلی، مجری برنامه دسترسی مستقیم به سخت‌افزار نداره و نمیتونه مستقیماً با مجودیتهایی مثل رم و دیسک تعامل کنه، بلکه نیازمند یه API از طرف سیستم عامل هست که با اون تعامل داشته باشه و از اون بخواد که براش اعمالش رو انجام بده. بعداً یه مقاله راجع به مفهوم API مینویسم. بنابرین این حالت امن تره و کد نسبت به سخت‌افزار ایزوله هست و اگر اشکالی پیش بیاد قابل جبرانه. بیشتر کدهایی که توی سیستم انجام میشن روی این مود هستن.</p><br />
<p>منابع این قسمت:</p>
<ul>
<li><em><a href="https://blog.codinghorror.com/understanding-user-and-kernel-mode">https://blog.codinghorror.com/understanding-user-and-kernel-mode</a></em></li>
<li><em><a href="https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys">https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys</a></em></li>
<li><em><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems</a></em></li>
<li><em><a href="https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine">https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine</a></em></li>
<li><em><a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></em></li>
</ul><br />
<p>حالا میتونیم یه تخمینی از متوسط زمان داشته باشیم: </p>
<pre><code class="language-md">(2501.88+2440.13+2446.16+2444.35+2515.03+2438.22+2493.81+2501.99+2459.47+2429.63) / 10 = 24670.67 / 10 = 2467.067
(2501.97+2440.23+2446.23+2444.5+2515.09+2438.28+2493.94+2502.09+2460.05+2429.75) / 10 = 24672.13 / 10 = 2467.213
(1046800+1046864+1046772+1046848+1046832+1046844+1046784+1046852+1046872+1046772) / 10 = 10468240 / 10 = 1046824
(2.51s+2.45s+2.45s+2.45s+2.52s+2.45s+2.50s+2.51s+2.47s+2.43s) / 10 = 24.74 / 10 = 2.474
(2.36s+2.32s+2.32s+2.29s+2.39s+2.32s+2.35s+2.37s+2.32s+2.32s) / 10 = 23.36 / 10 = 2.336
(0.14s+0.13s+0.13s+0.16s+0.13s+0.12s+0.15s+0.14s+0.15s+0.12s) / 10 = 1.37 / 10 = 0.137
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2467.067 ms
* Average Execution Time(Based on chrono): 2467.213 ms
* Average Memory Usage: 1046824 KB
* Average Real Time: 2.474 s
* Average User Time: 2.336 s
* Average Sys Time: 0.137 s
* Average CPU Usage: 99 %</code></pre><br />
<p>این نتایج رو در ذهن داشته باشین بعداً برای مقایسه بهش برمیگردیم. همین اوردر زمانی ذخیره سازی دیتا بصورت دسترسی تصادفی روی رم، سرعتی که لازم داریم برای مقایسه رو به ما میده، سرعتش در عمل برابری میکنه با خوندن چیزی از رم بصورت دسترسی تصادفی.</p><br />
<hr /><br />
<p>حالا بریم سراغ هارددیسک و ببینیم که خوندن/نوشتن یک گیگابایت از دیتا روی HDD چه مقدار زمان/ریسورس مصرف میکنه. البته در بحث این مقایسه دیگه ریسورسش (میزان رم مصرفیش) مد نظر ما نیست، بلکه زمانش برای ما مهمه. وقتی داریم رم رو با دیسک مقایسه میکنیم، دیگه نباید رمی که خود اعمال I/O مصرف میکنن رو بسنجیم.</p><br />
<p>کد زیر رو در نظر بگیرید:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    ofstream outfile;
    char character = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    outfile.open("output.txt");
    if (!outfile.is_open()) {
        cout &lt;&lt; "Error opening file!" &lt;&lt; endl;
        return 1;
    }
    for (int i = 0; i &lt; 1073741824; i++) {
        outfile &lt;&lt; character;
    }
    outfile.close();
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_write_test.cpp">فایل کد</a></p><br />
<p>این کد یه فایل به اسم output.txt باز میکنه (اگر نباشه میسازه و اگر باشه اوررایت میکنه{به اوررایتش برمیگردم}) و توش 1 گیگابایت داده مینویسه. من به رسم آزمایش 10 بار اجراش میکنم:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_write_test.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out 
Execution Time (Based on ctime): 9536.65 ms
Execution Time (Based on chrono): 9538.49 ms
Memory Usage: 0 KB

real    9.54s
user    8.85s
sys     0.68s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9530.77 ms
Execution Time (Based on chrono): 10150.1 ms
Memory Usage: 0 KB

real    10.15s
user    8.82s
sys     0.72s
cpu     93%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9625.24 ms
Execution Time (Based on chrono): 10063.4 ms
Memory Usage: 0 KB

real    10.07s
user    8.99s
sys     0.64s
cpu     95%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9655.58 ms
Execution Time (Based on chrono): 9657.09 ms
Memory Usage: 0 KB

real    9.66s
user    8.96s
sys     0.70s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9479.76 ms
Execution Time (Based on chrono): 9634.6 ms
Memory Usage: 0 KB

real    9.64s
user    8.89s
sys     0.60s
cpu     98%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9477.25 ms
Execution Time (Based on chrono): 9641.66 ms
Memory Usage: 0 KB

real    9.65s
user    8.92s
sys     0.56s
cpu     98%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9468.07 ms
Execution Time (Based on chrono): 9475.96 ms
Memory Usage: 0 KB

real    9.48s
user    8.70s
sys     0.77s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9761.29 ms
Execution Time (Based on chrono): 10151.8 ms
Memory Usage: 0 KB

real    10.16s
user    9.05s
sys     0.72s
cpu     96%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9632.74 ms
Execution Time (Based on chrono): 10079 ms
Memory Usage: 0 KB

real    10.08s
user    8.92s
sys     0.72s
cpu     95%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9536.97 ms
Execution Time (Based on chrono): 9540.68 ms
Memory Usage: 0 KB

real    9.55s
user    8.89s
sys     0.65s
cpu     99%</code></pre><br />
<p>و متوسط نتایج آزمایش به شرح زیره:</p>
<pre><code class="language-md">(9536.65+9530.77+9625.24+9655.58+9479.76+9477.25+9468.07+9761.29+9632.74+9536.97) / 10 = 95704.32 / 10 = 9570.432
(9538.49+10150.1+10063.4+9657.09+9634.6+9641.66+9475.96+10151.8+10079+9540.68) / 10 = 97932.78 / 10 = 9793.278
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(9.54s+10.15s+10.07s+9.66s+9.64s+9.65s+9.48s+10.16s+10.08s+9.55s) / 10 = 97.98 / 10 = 9.798
(8.85s+8.82s+8.99s+8.96s+8.89s+8.92s+8.70s+9.05s+8.92s+8.89s) / 10 = 88.99 / 10 = 8.899
(0.68s+0.72s+0.64s+0.70s+0.60s+0.56s+0.77s+0.72s+0.72s+0.65s) / 10 = 6.76 / 10 = 0.676
(99%+93%+95%+99%+98%+98%+99%+96%+95%+99%) / 10 = 971 / 10 = 97.1


Therefore:

* Average Execution Time(Based on ctime): 9570.432 ms
* Average Execution Time(Based on chrono): 9793.278 ms
* Average Memory Usage: 0 KB
* Average Real Time: 9.798 s
* Average User Time: 8.899 s
* Average Sys Time: 0.676 s
* Average CPU Usage: 97.1 %</code></pre><br />
<p>خب اینکه تقریباً 5 برابر کند تره! پس اون همه خزعبلات و دک و پز که عای 10 هزار برابر بطور متوسط کند تره چیشد؟! عجله نکنید، بیاین یواش یواش فاکتورهای دخیل رو به آزمایش اضافه کنیم.<br />
فرض کنید میخوایم 1 گیگابایت دیتایی که وجود داره رو اوررایت کنیم.</p><br />
<hr /><br />
<p>برای سنجش این حرکت داخل رم، من کد رو به این شکل تغییر میدم:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'B';    
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_overwrite_test.cpp">فایل کد</a></p><br />
<p>و اجرا میکنم:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_overwrite_test.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out              
Execution Time (Based on ctime): 2315.81 ms
Execution Time (Based on chrono): 2315.86 ms
Memory Usage: 0 KB

real    4.76s
user    4.61s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2321.07 ms
Execution Time (Based on chrono): 2321.15 ms
Memory Usage: 0 KB

real    4.80s
user    4.66s
sys     0.14s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2305.9 ms
Execution Time (Based on chrono): 2305.95 ms
Memory Usage: 0 KB

real    4.78s
user    4.67s
sys     0.11s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2331.96 ms
Execution Time (Based on chrono): 2332.03 ms
Memory Usage: 0 KB

real    4.79s
user    4.70s
sys     0.09s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2291.69 ms
Execution Time (Based on chrono): 2296.94 ms
Memory Usage: 0 KB

real    4.74s
user    4.57s
sys     0.16s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2336.1 ms
Execution Time (Based on chrono): 2339.92 ms
Memory Usage: 0 KB

real    4.85s
user    4.71s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2330.54 ms
Execution Time (Based on chrono): 2330.6 ms
Memory Usage: 0 KB

real    4.82s
user    4.70s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2283.55 ms
Execution Time (Based on chrono): 2283.58 ms
Memory Usage: 0 KB

real    4.72s
user    4.59s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2328.87 ms
Execution Time (Based on chrono): 2328.91 ms
Memory Usage: 0 KB

real    4.79s
user    4.67s
sys     0.12s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2295.38 ms
Execution Time (Based on chrono): 2296.14 ms
Memory Usage: 0 KB

real    4.75s
user    4.60s
sys     0.15s
cpu     99%</code></pre><br />
<p>و متوسط نتیجه:</p>
<pre><code class="language-md">(2315.81+2321.07+2305.9+2331.96+2291.69+2336.1+2330.54+2283.55+2328.87+2295.38) / 10 = 23140.87 / 10 = 2314.087
(2315.86+2321.15+2305.95+2332.03+2296.94+2339.92+2330.6+2283.58+2328.91+2296.14) / 10 = 23151.08 / 10 = 2315.108
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(4.76s+4.80s+4.78s+4.79s+4.74s+4.85s+4.82s+4.72s+4.79s+4.75s) / 10 = 47.8 / 10 = 4.78
(4.61s+4.66s+4.67s+4.70s+4.57s+4.71s+4.70s+4.59s+4.67s+4.60s) / 10 = 46.48 / 10 = 4.648
(0.14s+0.14s+0.11s+0.09s+0.16s+0.12s+0.12s+0.12s+0.12s+0.15s) / 10 = 1.27 / 10 = 0.127
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2314.087 ms
* Average Execution Time(Based on chrono): 2315.108 ms
* Average Memory Usage: 0 KB
* Average Real Time: 4.78 s
* Average User Time: 4.648 s
* Average Sys Time: 0.127 s
* Average CPU Usage: 99 %</code></pre><br />
<p>همونطور که میبینید زمان اوررایت کردن برابری میکنه با زمان رایت کردن.<br />
نکته1: قسمت مد نظر ما برای مقایسه صرفاً زمانی هست که اون سگمنت بخصوص کد یعنی:</p>
<pre><code class="language-cpp">for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'B'; </code></pre><br />
<p>انجام میشده. که در‌واقع میشه:</p>
<pre><code class="language-md">* Average Execution Time(Based on ctime): 2314.087 ms
* Average Execution Time(Based on chrono): 2315.108 ms</code></pre><br />
<p>نکته2: میزان مموری مصرفی این سگمنت کد 0 ریپورت شده چون هیچ مموری الوکیشن جدیدی نداشتیم (در حقیقت داشتیم مثلاً برای شمارنده حلقه فور، ولی اینقدر کوشولو هست که توی اوردر کیلوبایت دیده نشده) – وقتی ما حافظه‌ای نیو نکردیم، و صرفاً قبلی رو اوورایت کردیم مموری یوزیج جدیدی ریپورت نشده. ولی در‌واقع ما با 1 گیگابایت مموری کار کردیم.</p><br />
<p>حالا بریم سراغ هارددیسک، من از همون کد قبلی استفاده میکنم، منتهی این بار دیگه فایلهای 1 گیگی ساخته شده پیشین رو حذف (rm) نمیکنم تا اوررایت بشن:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_write_test.cpp    

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out 
Execution Time (Based on ctime): 10162.1 ms
Execution Time (Based on chrono): 16532.7 ms
Memory Usage: 0 KB

real    16.54s
user    9.30s
sys     0.87s
cpu     61%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9961.45 ms
Execution Time (Based on chrono): 19035.1 ms
Memory Usage: 0 KB

real    19.04s
user    9.10s
sys     0.86s
cpu     52%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9925.02 ms
Execution Time (Based on chrono): 19885.7 ms
Memory Usage: 0 KB

real    19.89s
user    9.14s
sys     0.79s
cpu     49%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9927.78 ms
Execution Time (Based on chrono): 20518.4 ms
Memory Usage: 0 KB

real    20.52s
user    9.04s
sys     0.89s
cpu     48%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9996.59 ms
Execution Time (Based on chrono): 17915.4 ms
Memory Usage: 0 KB

real    17.92s
user    9.16s
sys     0.84s
cpu     55%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9659.78 ms
Execution Time (Based on chrono): 19085.9 ms
Memory Usage: 0 KB

real    19.09s
user    8.91s
sys     0.76s
cpu     50%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 10051.7 ms
Execution Time (Based on chrono): 19261.9 ms
Memory Usage: 0 KB

real    19.27s
user    9.25s
sys     0.81s
cpu     52%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 10124.3 ms
Execution Time (Based on chrono): 19965.3 ms
Memory Usage: 0 KB

real    19.97s
user    9.31s
sys     0.82s
cpu     50%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9867.27 ms
Execution Time (Based on chrono): 19433.7 ms
Memory Usage: 0 KB

real    19.44s
user    9.05s
sys     0.82s
cpu     50%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 9850.91 ms
Execution Time (Based on chrono): 18046 ms
Memory Usage: 0 KB

real    18.05s
user    8.96s
sys     0.89s
cpu     54%</code></pre><br />
<p>متوسط میگیریم:</p>
<pre><code class="language-md">(10162.1+9961.45+9925.02+9927.78+9996.59+9659.78+10051.7+10124.3+9867.27+9850.91) / 10 = 99526.9 / 10 = 9952.69
(16532.7+19035.1+19885.7+20518.4+17915.4+19085.9+19261.9+19965.3+19433.7+18046) / 10 = 189680.1 / 10 = 18968.01
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(16.54s+19.04s+19.89s+20.52s+17.92s+19.09s+19.27s+19.97s+19.44s+18.05s) / 10 = 189.73 / 10 = 18.973
(9.30s+9.10s+9.14s+9.04s+9.16s+8.91s+9.25s+9.31s+9.05s+8.96s) / 10 = 91.22 / 10 = 9.122
(0.87s+0.86s+0.79s+0.89s+0.84s+0.76s+0.81s+0.82s+0.82s+0.89s) / 10 = 8.35 / 10 = 0.835
(61%+52%+49%+48%+55%+50%+52%+50%+50%+54%) / 10 = 521 / 10 = 52.1


Therefore:

* Average Execution Time(Based on ctime): 9952.69 ms
* Average Execution Time(Based on chrono): 18968.01 ms
* Average Memory Usage: 0 KB
* Average Real Time: 18.973 s
* Average User Time: 9.122 s
* Average Sys Time: 0.835 s
* Average CPU Usage: 52.1 %</code></pre><br />
<p>اهوع! نتیجه 10 برابر کندتر شد. اما هنوز صبر کنید:)) داستان ادامه داره…</p><br />
<p>نکته1: به زمان اجرای اولین اوررایت HDD نگاه کنید و به زمان متوسط محاسبه شده نگاه کنید، و متوجه میشین که چرا گفتم هر آزمایش رو باید حداقل چندین بار تکرار کنیم.</p><br />
<p>نکته2: همونطور که میبینین زمان محاسبه شده توسط chrono خیلی بیشتر (تقریباً دو برابر) زمان محاسبه شده توسط ctime هست و زمان واقعی اجرای اون بلاک کد رو بیان میکنه. اما چرا؟<br />
داستان یچیزی شبیه اون زمانهای real و user و sys هست که توی بحث کامند time گفتم، دلیل علمی اینه که این دو کتابخونه زمان رو به روشهای متفاوتی محاسبه میکنن. Ctime یه کتابخونه مختص زبان سی هست که اینجا با استفاده از فانکشن <code>clock()</code> زمان رو محاسبه میکنه، اما نه زمان دقیق رو، بلکه زمانی رو که CPU صرف محاسبات این پراسس فعلی کرده. اما این گزاره بازم دقیق نیست، یکمی به زبان تخصصی تر میگم، سی‌تایم با استفاده از فانکشن کلاک، تعداد کلاکهایی که CPU حین محاسبات همین برنامه بخصوص زده رو ثبت میکنه، و سپس معادل این کلاکهارو به زمان ثانیه‌ای بیان میکنه. صرفاً یعنی CPU روی این پراسس خاص چند تا کلاک زده، این معنیش اینه که زمانی که ما داشتیم I/O میزدیم و یا منتظر ریسورس یا I/O بلاک بودیم یا منتظر دیگر پراسسها بودیم رو توی محاسباتش دخیل نمیکنه، در صورتی که سنجش میزان زمان I/O اصلاً بخش بزرگی از محاسبات ماست! اما chrono داستانی کاملاً متفاوت داره… <br />
کتابخونه  chrono زمانی که روی متد های‌رزولوشن (<code>high_resolution_clock</code>) کال میشه، به اصطلاح زمان دقیق ساعت دیواری رو محاسبه میکنه، از نقطه شروع تا نقطه پایان. این زمان شامل اینتراپتها و I/O های داستان هم هست. پس این زمان دقیقی هست که باهاش مقایسه رو انجام میدیم.</p><br />
<hr /><br />
<p>خب حالا بیاین دامنه مقایسه رو کمی گسترش بدیم، فرض کنید میخوایم یه کپی پیست ساده رو توی RAM و توی HDD مقایسه کنیم، برای رم کد زیر رو در نظر بگیرین:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    char* arr_2 = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr_2[i] = arr[i];    
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_copy_test.cpp">فایل کد</a></p><br />
<p>و یه راست بریم سراغ اجرا:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_copy_test.cpp     

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2676.01 ms
Execution Time (Based on chrono): 2676.22 ms
Memory Usage: 1048824 KB

real    5.12s
user    4.89s
sys     0.23s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2616.64 ms
Execution Time (Based on chrono): 2616.71 ms
Memory Usage: 1048764 KB

real    5.06s
user    4.85s
sys     0.20s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2618.32 ms
Execution Time (Based on chrono): 2618.4 ms
Memory Usage: 1048712 KB

real    5.02s
user    4.81s
sys     0.20s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2616.12 ms
Execution Time (Based on chrono): 2616.2 ms
Memory Usage: 1048824 KB

real    5.05s
user    4.80s
sys     0.24s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2617.68 ms
Execution Time (Based on chrono): 2617.75 ms
Memory Usage: 1048824 KB

real    5.05s
user    4.88s
sys     0.17s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2620.01 ms
Execution Time (Based on chrono): 2620.11 ms
Memory Usage: 1048824 KB

real    5.06s
user    4.86s
sys     0.20s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2620.11 ms
Execution Time (Based on chrono): 2620.16 ms
Memory Usage: 1048824 KB

real    5.02s
user    4.79s
sys     0.23s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2615.65 ms
Execution Time (Based on chrono): 2615.84 ms
Memory Usage: 1048764 KB

real    5.03s
user    4.78s
sys     0.25s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2623.07 ms
Execution Time (Based on chrono): 2623.13 ms
Memory Usage: 1048780 KB

real    5.03s
user    4.86s
sys     0.17s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 2616.85 ms
Execution Time (Based on chrono): 2616.94 ms
Memory Usage: 1048780 KB

real    5.07s
user    4.87s
sys     0.20s
cpu     99%</code></pre><br />
<p>و اوریج نتیجه:</p>
<pre><code class="language-md">(2676.01+2616.64+2618.32+2616.12+2617.68+2620.01+2620.11+2615.65+2623.07+2616.85) / 10 = 26240.46 / 10 = 2624.046
(2676.22+2616.71+2618.4+2616.2+2617.75+2620.11+2620.16+2615.84+2623.13+2616.94) / 10 = 26241.46 / 10 = 2624.146
(1048824+1048764+1048712+1048824+1048824+1048824+1048824+1048764+1048780+1048780) / 10 = 10487920 / 10 = 1048792
(5.12s+5.06s+5.02s+5.05s+5.05s+5.06s+5.02s+5.03s+5.03s+5.07s) / 10 = 50.51 / 10 = 5.051
(4.89s+4.85s+4.81s+4.80s+4.88s+4.86s+4.79s+4.78s+4.86s+4.87s) / 10 = 48.39 / 10 = 4.839
(0.23s+0.20s+0.20s+0.24s+0.17s+0.20s+0.23s+0.25s+0.17s+0.20s) / 10 = 2.09 / 10 = 0.209
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2624.046 ms
* Average Execution Time(Based on chrono): 2624.146 ms
* Average Memory Usage: 1048792 KB
* Average Real Time: 5.051 s
* Average User Time: 4.839 s
* Average Sys Time: 0.209 s
* Average CPU Usage: 99 %</code></pre><br />
<hr /><br />
<p>حالا کپی کردن همون 1 گیگابایت دیتا از روی دیسک، روی همون دیسک ولی یه جای دیگه‌ش، مثلاً توی یه پارتیشن دیگه<em>-</em>: </p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char chunk;
    ifstream infile;
    ofstream outfile;

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    infile.open("output.txt");
    outfile.open("/media/user/MyDrive1/output_copy.txt");
    if (!outfile.is_open()) {
        cout &lt;&lt; "Error opening file!" &lt;&lt; endl;
        return 1;
    }
    while (infile.get(chunk))
        outfile.put(chunk);
    infile.close();
    outfile.close();
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_copy_test.cpp">فایل کد</a></p><br />
<p>اجرا:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_copy_test.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./a.out
Execution Time (Based on ctime): 18386.5 ms
Execution Time (Based on chrono): 25923.6 ms
Memory Usage: 0 KB

real    25.93s
user    16.58s
sys     1.81s
cpu     70%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; !!

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 17681.3 ms
Execution Time (Based on chrono): 23741.9 ms
Memory Usage: 0 KB

real    23.74s
user    15.98s
sys     1.70s
cpu     74%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 17245.1 ms
Execution Time (Based on chrono): 24897.7 ms
Memory Usage: 0 KB

real    24.90s
user    15.49s
sys     1.76s
cpu     69%


┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt      
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1874 s, 105 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 19407.6 ms
Execution Time (Based on chrono): 33033.6 ms
Memory Usage: 0 KB

real    33.04s
user    17.42s
sys     1.99s
cpu     58%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.4907 s, 102 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20163.5 ms
Execution Time (Based on chrono): 36565.9 ms
Memory Usage: 0 KB

real    36.57s
user    18.03s
sys     2.13s
cpu     55%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1993 s, 105 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20450.9 ms
Execution Time (Based on chrono): 38170.3 ms
Memory Usage: 0 KB

real    38.17s
user    18.30s
sys     2.15s
cpu     53%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1726 s, 106 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20228.9 ms
Execution Time (Based on chrono): 33791.1 ms
Memory Usage: 0 KB

real    33.79s
user    18.12s
sys     2.11s
cpu     59%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.2377 s, 105 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20001.4 ms
Execution Time (Based on chrono): 35478 ms
Memory Usage: 0 KB

real    35.48s
user    17.79s
sys     2.21s
cpu     56%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.5428 s, 102 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 19954.7 ms
Execution Time (Based on chrono): 34560.4 ms
Memory Usage: 0 KB

real    34.56s
user    17.55s
sys     2.41s
cpu     57%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1674 s, 106 MB/s

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 21618.5 ms
Execution Time (Based on chrono): 39370.6 ms
Memory Usage: 0 KB

real    39.37s
user    19.18s
sys     2.44s
cpu     54%</code></pre><br />
<p>متوسط زمان:</p>
<pre><code class="language-md">(18386.5+17681.3+17245.1+19407.6+20163.5+20450.9+20228.9+20001.4+19954.7+21618.5) / 10 = 195138.4 / 10 = 19513.84
(25923.6+23741.9+24897.7+33033.6+36565.9+38170.3+33791.1+35478+34560.4+39370.6) / 10 = 325533.1 / 10 = 32553.31
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(25.93s+23.74s+24.90s+33.04s+36.57s+38.17s+33.79s+35.48s+34.56s+39.37s) / 10 = 325.55 / 10 = 32.555
(16.58s+15.98s+15.49s+17.42s+18.03s+18.30s+18.12s+17.79s+17.55s+19.18s) / 10 = 174.44 / 10 = 17.444
(1.81s+1.70s+1.76s+1.99s+2.13s+2.15s+2.11s+2.21s+2.41s+2.44s) / 10 = 20.71 / 10 = 2.071
(70%+74%+69%+58%+55%+53%+59%+56%+57%+54%) / 10 = 605 / 10 = 60.5


Therefore:

* Average Execution Time(Based on ctime): 19513.84 ms
* Average Execution Time(Based on chrono): 32553.31 ms
* Average Memory Usage: 0 KB
* Average Real Time: 32.555 s
* Average User Time: 17.444 s
* Average Sys Time: 2.071 s
* Average CPU Usage: 60.5 %</code></pre><br />
<p>اینجا من یه حقه ظریف پیاده‌سازی کردم:))</p><br />
<p>فقط به زبان تخصصی توضیحش میدم، با کپی کردن سریع توی رنج 20 ثانیه فهمیدم که یه بهینه‌سازی اون زیر در جریانه، ممکنه فایل توسط یه موجودیتی کش شده باشه – سیستم عامل یا ماژولهای API مربوط به I/O – (و میبینیم که در عمل مسائل تئوریک چطوری جلوی واقعی پیدا میکنن) و از اونجایی که آنتروپی فایل خیـــلی پایینه، (چون همش اسکی «A» هست) شاید آزمایش ما متأثر از بهینگی هایی باشه که قبلتر بصورت تئوریک توضیح دادم، برای همین منظور، با دستورات زیر 1 گیگابایت اطلاعات رندوم از آنتروپی سیستم گرفتم به جای فایل Low-entropyمون گذاشتم و دیدیم که زمان بسیار طولانی‌تر شد (حتی تا 20 برابر طولانی تر).</p>
<pre><code class="language-bash">rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt</code></pre><br />
<hr /><br />
<p>میخوام مقایسه آخرو کنم و تیر خلاصو بزنم و این بازی رو جمعش کنم، برای این منظور مقایسه رو به شمایلی انجام میدیم که چندتا پروسس بطور موازی دارن ریسورس رو مصرف میکنن و مثلاً با هارددیسک یا رم تعامل مستقیم دارن… تا ببینیم وقتی دیوایس ذخیره سازی ما تحت دسترسی مشترکه، چه میزان زمان خدمت دهیش میاد پایین، چه در رم چه در دیسک.<br />
از اونچیزایی که توی تئوری گفتیم میدونیم رم براش فرقی نداره و سرعتش خیــــلی متأثر از این موضوع نیست، پس نباید خیلی زیاد کندتر بشه، اما دیسک بخاطر حرکات فیزیکیش، احتمالاً باید بشدت سرعتش نابود بشه، بریم و در عمل ببینیم:</p><br />
<p>برنامه زیر کارش خوردن رمه! 1 گیگابایت از رمو میگیره و هی پر و خالی میکنه:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    cout &lt;&lt; "EATING RAM!!!" &lt;&lt; endl;
    while( true )
    {
        char* arr = new char[1073741824];
        for(int i = 0; i &lt; 1073741824 ; i++)
            arr[i] = 'A';
        delete arr;
    }

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_eater_test.cpp">فایل کد</a></p><br />
<p>من چهارتا پراسس از این برنامه بطور موازی اجرا میکنم:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_eater.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
EATING RAM!!!</code></pre>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
EATING RAM!!!</code></pre>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
EATING RAM!!!</code></pre>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
EATING RAM!!!</code></pre><br />
<p><img src="Files/13.png" alt="Executing RAM-eaters" /></p><br />
<p>و خروجی top وقتی چهارتا پراسس رمخور در حال اجرا هستن:</p><br />
<p><img src="Files/14.png" alt="top command result" /></p><br />
<p>حالا بطور همزمان با اینها، برنامه اولمون یعنی <a href="./Files/RAM_write_test.cpp">اینو</a> اجرا میکنم:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_write_test.cpp -o test.out

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out                   
Execution Time (Based on ctime): 3638.12 ms
Execution Time (Based on chrono): 3638.24 ms
Memory Usage: 1047004 KB

real    3.67s
user    3.45s
sys     0.22s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3539.23 ms
Execution Time (Based on chrono): 3539.71 ms
Memory Usage: 1046948 KB

real    3.56s
user    3.36s
sys     0.20s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3587.88 ms
Execution Time (Based on chrono): 3588.17 ms
Memory Usage: 1046956 KB

real    3.63s
user    3.43s
sys     0.20s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3629.68 ms
Execution Time (Based on chrono): 3630.07 ms
Memory Usage: 1046968 KB

real    3.67s
user    3.43s
sys     0.24s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3568.61 ms
Execution Time (Based on chrono): 3568.84 ms
Memory Usage: 1046920 KB

real    3.59s
user    3.39s
sys     0.21s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3578.81 ms
Execution Time (Based on chrono): 3578.97 ms
Memory Usage: 1046828 KB

real    3.61s
user    3.39s
sys     0.22s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3585.52 ms
Execution Time (Based on chrono): 3585.62 ms
Memory Usage: 1046760 KB

real    3.61s
user    3.33s
sys     0.28s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3566.91 ms
Execution Time (Based on chrono): 3567.07 ms
Memory Usage: 1046944 KB

real    3.60s
user    3.37s
sys     0.22s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3594.36 ms
Execution Time (Based on chrono): 3594.45 ms
Memory Usage: 1046972 KB

real    3.63s
user    3.39s
sys     0.24s
cpu     99%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./test.out
Execution Time (Based on ctime): 3584.68 ms
Execution Time (Based on chrono): 3588.76 ms
Memory Usage: 1046840 KB

real    3.62s
user    3.35s
sys     0.27s
cpu     99%</code></pre><br />
<p>و متوسط آزمایش:</p>
<pre><code class="language-md">(3638.12+3539.23+3587.88+3629.68+3568.61+3578.81+3585.52+3566.91+3594.36+3584.68) / 10 = 35873.8 / 10 = 3587.38
(3638.24+3539.71+3588.17+3630.07+3568.84+3578.97+3585.62+3567.07+3594.45+3588.76) / 10 = 35879.9 / 10 = 3587.99
(1047004+1046948+1046956+1046968+1046920+1046828+1046760+1046944+1046972+1046840) / 10 = 10469140 / 10 = 1046914
(3.67s+3.56s+3.63s+3.67s+3.59s+3.61s+3.61s+3.60s+3.63s+3.62s) / 10 = 36.19 / 10 = 3.619
(3.45s+3.36s+3.43s+3.43s+3.39s+3.39s+3.33s+3.37s+3.39s+3.35s) / 10 = 33.89 / 10 = 3.389
(0.22s+0.20s+0.20s+0.24s+0.21s+0.22s+0.28s+0.22s+0.24s+0.27s) / 10 = 2.3 / 10 = 0.23
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 3587.38 ms
* Average Execution Time(Based on chrono): 3587.99 ms
* Average Memory Usage: 1046914 KB
* Average Real Time: 3.619 s
* Average User Time: 3.389 s
* Average Sys Time: 0.23 s
* Average CPU Usage: 99 %</code></pre><br />
<p>میبینیم که متوسط زمان حدوداً 1.5 برابر شده، البته این افزایش زمان لزوماً به معنی کند شدن چیپ رم نیست، ممکنه بخاطر شلوغ شدن باس رم، یا شلوغ شدن ماژول سیستم عاملی رم، یا شلوغ شدن اون API که پراسسا باهاش تعامل میکنن برای تخصیص مموری، یا حتی شلوغ شدن سر پردازنده باشه..!<br />
برای اینکه مطمئن بشیم بخاطر پردازنده نیست، آزمایش بالا رو بصورت مالتی‌تردینگ یا چندنخی تکرار میکنم و هر رم-خور رو روی یه هسته جدا میذارم و همچنین پراسس آزمون هم روی یه هسته جدا میذارم (جمعا 5 هسته)<br />
به زبان ساده، یه برنامه چندنخی محاسبات نخهای متفاوت رو روی هسته های متفاوت میچینه، با این کار ما مطمئن میشیم کندی سرعت صرفاً بخاطر شلوغی پردازنده نیست….(بعداً راجع به چندنخی یا مالتی پراسسینگ توی یه مقاله مفصل حرف میزنیم.)</p><br />
<hr /><br />
<p>برنامه زیر رو در نظر بگیرید:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std;

void ram_eater()
{
    cout &lt;&lt; "A ram-eater started eating!" &lt;&lt; endl;
    while( true )
    {
        char* arr = new char[1073741824];
        for(int i = 0; i &lt; 1073741824 ; i++)
            arr[i] = 'A';
        delete arr;
    }
}

void test()
{
    for( int i = 0; i &lt; 10; i++ )
    {
        // Start execution time
        clock_t start_1 = clock();
        auto start_2 = chrono::high_resolution_clock::now();

        // Start memory usage
        struct rusage usage;
        getrusage(RUSAGE_SELF, &amp;usage);
        long memory_usage_start = usage.ru_maxrss; // in kilobytes

        // Code ----------------------------------------------------------
        char* arr = new char[1073741824];
        for(int j = 0; j &lt; 1073741824 ; j++)
            arr[j] = 'A';

        // ---------------------------------------------------------------

        // Stop measuring memory usage
        getrusage(RUSAGE_SELF, &amp;usage);
        long memory_usage_end = usage.ru_maxrss; // in kilobytes

        // Stop measuring execution time
        clock_t end_1 = clock();
        auto end_2 = chrono::high_resolution_clock::now();
        double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
        chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

        // Printing result
        cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
        cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
        cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

        // Free memory to prevent memory-leak
        delete arr;

        // Sleep for 10 seconds
        this_thread::sleep_for(chrono::milliseconds(10000)); 
    }
}

int main() {
    vector&lt;thread&gt; threads;

    threads.emplace_back(ram_eater);
    threads.emplace_back(ram_eater);
    threads.emplace_back(ram_eater);
    threads.emplace_back(ram_eater);

    threads.emplace_back(test);

    // Wait for test to be over
    threads[4].join();

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_eating_multithreading_test.cpp">فایل کد</a></p><br />
<p>اجرا:</p><br />
<p><img src="Files/15.png" alt="Executing RAM_eating_multithreading_test.cpp" /></p>
<pre><code class="language-diff">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_eating_multithreading_test.cpp

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out                               
A ram-eater started eating!
A ram-eater started eating!
A ram-eater started eating!
A ram-eater started eating!
Execution Time (Based on ctime): 12877.4 ms
-Execution Time (Based on chrono): 2576.37 ms
Memory Usage: 4595268 KB
Execution Time (Based on ctime): 14381.2 ms
-Execution Time (Based on chrono): 2879.22 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18355.6 ms
-Execution Time (Based on chrono): 3672.86 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18452.8 ms
-Execution Time (Based on chrono): 3692.51 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 17189.4 ms
-Execution Time (Based on chrono): 3442.85 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18136.1 ms
-Execution Time (Based on chrono): 3625.81 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 17982.1 ms
-Execution Time (Based on chrono): 3599.67 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18238.8 ms
-Execution Time (Based on chrono): 3648.24 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18639.8 ms
-Execution Time (Based on chrono): 3729.46 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18598.2 ms
-Execution Time (Based on chrono): 3719.59 ms
Memory Usage: 0 KB
terminate called without an active exception
zsh: IOT instruction  ./a.out</code></pre><br />
<p>میبینین که برنامه داره روی چند هسته اجرا میشه و از اونجایی که همه چی تحت یه پراسس هست، زمان ctime و میزان مموری مصرفی داده‌های پرتی هستن که بدرد آزمایش ما نمیخورن، فقط زمان chrono که به رنگ قرمز (علامت – مارکداون) مشخص کردم زمان درستی هست که باید توی مقایسه دخیل بشه، متوسط زمان به شرح زیره:</p>
<pre><code class="language-md">(2576.37+2879.22+3672.86+3692.51+3442.85+3625.81+3599.67+3648.24+3729.46+3719.59) / 10 = 34586.58 / 10 = 3458.658

Therefore:

* Average Execution Time(Based on chrono): 3458.658 ms</code></pre><br />
<p>متوسط زمان بصورت چندنخی بدست اومد 3458.658 میلی‌ثانیه که تقریباً برابر با همون متوسط زمان چندپراسسی یعنی 3587.99 میلی‌ثانیه برابر هست. پس میتونیم ضمن تخصیص 100 میلی ثانیه بطور متوسط به اتلاف وقت پردازنده، با قطعیت بگیم که رم تحت یه سیستم یونیکسی، حین دسترسی مشترک – اونم بصورت مرگبار! - فقط 1.5 برابر کند تر میشه.<br />
اینکه گفتم بصورت مرگبار، هر بار مانیتورینگ رم رو توی لاگ htop که فرستادم بینید که متوجه بشین رم چقدر درگیر بوده.</p><br />
<hr /><br />
<p>حالا بریم سراغ همین دسترسی مشترک توی هارددیسک، برای این منظور یه برنامه دیسک-خور مینویسیم!:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;signal.h&gt;
#include &lt;ctime&gt;

using namespace std;

ofstream outfile;

void signalHandler(int signum) {
    outfile.close();
    cout &lt;&lt; "Interrupt signal received. File closed." &lt;&lt; endl;
    exit(signum);
}

int main() {
    signal(SIGINT, signalHandler);
    srand(time(NULL));
    char character = 'A';
    string filename = to_string(rand()) + ".txt";

    cout &lt;&lt; "EATING HDD!!!" &lt;&lt; endl;


    while (true) {

        outfile.open(filename);
        if (!outfile.is_open()) {
            cout &lt;&lt; "Error opening file: " &lt;&lt; filename &lt;&lt; endl;
            return 1;
        }

        for (int i = 0; i &lt; 1073741824; i++) {
            outfile &lt;&lt; character;
        }

        outfile.close();
    }

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_eater.cpp">فایل کد</a></p><br />
<p>یه توضیح مختصری بدم، این برنامه یسری فایل با اسم رندوم میسازه و توی هر کدوم 1 گیگابایت دیتا مینویسه و وقتی فرایند نوشتن تموم شد، دوباره شروع میکنه و از اول مینویسه. این فرایند تا بینهایت ادامه پیدا میکنه مگر اینکه یه سیگنال وقفه برای برنامه ارسال بشه. به محض دریافت وقفه، فایل رو میبنده و برنامه به اتمام میرسه.</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_eater.cpp -o HDD_eater.out

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./HDD_eater.out 
EATING HDD!!!</code></pre>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./HDD_eater.out 
EATING HDD!!!</code></pre>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./HDD_eater.out 
EATING HDD!!!</code></pre>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./HDD_eater.out 
EATING HDD!!!</code></pre><br />
<p><img src="Files/16.png" alt="Executing HDD-eaters" /></p><br />
<p>و حین همین ماجرا، <a href="./Files/HDD_write_test.cpp">این</a> برنامه رو اجرا میکنم:</p>
<pre><code class="language-bash">┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ HDD_write_test.cpp -o HDD_write.out

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out 
Execution Time (Based on ctime): 11230.8 ms
Execution Time (Based on chrono): 25468.1 ms
Memory Usage: 0 KB

real    25.48s
user    10.30s
sys     0.93s
cpu     44%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 11096.1 ms
Execution Time (Based on chrono): 20764 ms
Memory Usage: 0 KB

real    20.77s
user    10.16s
sys     0.94s
cpu     53%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 13815.2 ms
Execution Time (Based on chrono): 32682 ms
Memory Usage: 0 KB

real    32.68s
user    12.63s
sys     1.18s
cpu     42%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 15544.6 ms
Execution Time (Based on chrono): 47560 ms
Memory Usage: 0 KB

real    47.57s
user    13.91s
sys     1.64s
cpu     32%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 16873.7 ms
Execution Time (Based on chrono): 45354.9 ms
Memory Usage: 0 KB

real    45.36s
user    15.25s
sys     1.63s
cpu     37%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 15391.3 ms
Execution Time (Based on chrono): 39712.6 ms
Memory Usage: 0 KB

real    39.92s
user    13.94s
sys     1.46s
cpu     38%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 14051.7 ms
Execution Time (Based on chrono): 29361.3 ms
Memory Usage: 0 KB

real    29.36s
user    12.61s
sys     1.44s
cpu     47%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 13137.5 ms
Execution Time (Based on chrono): 35374 ms
Memory Usage: 0 KB

real    35.64s
user    11.94s
sys     1.21s
cpu     36%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 13510.7 ms
Execution Time (Based on chrono): 28392.7 ms
Memory Usage: 0 KB

real    28.40s
user    12.42s
sys     1.10s
cpu     47%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 13595 ms
Execution Time (Based on chrono): 44944.2 ms
Memory Usage: 0 KB

real    44.95s
user    12.24s
sys     1.35s
cpu     30%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 18275.6 ms
Execution Time (Based on chrono): 70660.9 ms
Memory Usage: 0 KB

real    70.66s
user    16.16s
sys     2.11s
cpu     25%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 17255 ms
Execution Time (Based on chrono): 49479.4 ms
Memory Usage: 0 KB

real    49.48s
user    15.43s
sys     1.82s
cpu     34%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 15195.9 ms
Execution Time (Based on chrono): 52613.5 ms
Memory Usage: 0 KB

real    52.62s
user    13.64s
sys     1.56s
cpu     28%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 14688.6 ms
Execution Time (Based on chrono): 54965.7 ms
Memory Usage: 0 KB

real    54.97s
user    13.33s
sys     1.36s
cpu     26%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 18287.1 ms
Execution Time (Based on chrono): 61944 ms
Memory Usage: 0 KB

real    61.95s
user    16.30s
sys     1.98s
cpu     29%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 21118.9 ms
Execution Time (Based on chrono): 70709.4 ms
Memory Usage: 0 KB

real    70.71s
user    19.07s
sys     2.05s
cpu     29%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 24345 ms
Execution Time (Based on chrono): 82900.9 ms
Memory Usage: 0 KB

real    82.90s
user    21.94s
sys     2.41s
cpu     29%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 18640.5 ms
Execution Time (Based on chrono): 56225.7 ms
Memory Usage: 0 KB

real    56.23s
user    16.70s
sys     1.94s
cpu     33%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 17671.1 ms
Execution Time (Based on chrono): 68766 ms
Memory Usage: 0 KB

real    68.77s
user    16.09s
sys     1.58s
cpu     25%

┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ time ./HDD_write.out
Execution Time (Based on ctime): 22847.9 ms
Execution Time (Based on chrono): 88525.2 ms
Memory Usage: 0 KB

real    88.53s
user    20.43s
sys     2.42s
cpu     25%</code></pre>
<pre><code class="language-md">(11230.8+11096.1+13815.2+15544.6+16873.7+15391.3+14051.7+13137.5+13510.7+13595+18275.6+17255+15195.9+14688.6+18287.1+21118.9+24345+18640.5+17671.1+22847.9) / 20 = 326572.2 / 20 = 16328.61
(25468.1+20764+32682+47560+45354.9+39712.6+29361.3+35374+28392.7+44944.2+70660.9+49479.4+52613.5+54965.7+61944+70709.4+82900.9+56225.7+68766+88525.2) / 20 = 1006404.5 / 20 = 50320.225
(0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0) / 20 = 0 / 20 = 0
(25.48s+20.77s+32.68s+47.57s+45.36s+39.92s+29.36s+35.64s+28.40s+44.95s+70.66s+49.48s+52.62s+54.97s+61.95s+70.71s+82.90s+56.23s+68.77s+88.53s) / 20 = 1006.95 / 20 = 50.3475
(10.30s+10.16s+12.63s+13.91s+15.25s+13.94s+12.61s+11.94s+12.42s+12.24s+16.16s+15.43s+13.64s+13.33s+16.30s+19.07s+21.94s+16.70s+16.09s+20.43s) / 20 = 294.49 / 20 = 14.7245
(0.93s+0.94s+1.18s+1.64s+1.63s+1.46s+1.44s+1.21s+1.10s+1.35s+2.11s+1.82s+1.56s+1.36s+1.98s+2.05s+2.41s+1.94s+1.58s+2.42s) / 20 = 32.11 / 20 = 1.6055
(44%+53%+42%+32%+37%+38%+47%+36%+47%+30%+25%+34%+28%+26%+29%+29%+29%+33%+25%+25%) / 20 = 689 / 20 = 34.45


Therefore:

* Average Execution Time(Based on ctime): 16328.61 ms
* Average Execution Time(Based on chrono): 50320.225 ms
* Average Memory Usage: 0 KB
* Average Real Time: 50.3475 s
* Average User Time: 14.7245 s
* Average Sys Time: 1.6055 s
* Average CPU Usage: 34.45 %</code></pre><br />
<p>این نمودار رو نگاه کنین، در 20 آزمایش اول، میزان زمان به این شکل کند تر شده:</p><br />
<p><img src="Files/17.png" alt="HDD speed chart in 20 tests" /></p>
<table>
<thead>
<tr>
<th>Test#</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>25468.1</td>
</tr>
<tr>
<td>2</td>
<td>20764</td>
</tr>
<tr>
<td>3</td>
<td>32682</td>
</tr>
<tr>
<td>4</td>
<td>47560</td>
</tr>
<tr>
<td>5</td>
<td>45354.9</td>
</tr>
<tr>
<td>6</td>
<td>39712.6</td>
</tr>
<tr>
<td>7</td>
<td>29361.3</td>
</tr>
<tr>
<td>8</td>
<td>35374</td>
</tr>
<tr>
<td>9</td>
<td>28392.7</td>
</tr>
<tr>
<td>10</td>
<td>44944.2</td>
</tr>
<tr>
<td>11</td>
<td>70660.9</td>
</tr>
<tr>
<td>12</td>
<td>49479.4</td>
</tr>
<tr>
<td>13</td>
<td>52613.5</td>
</tr>
<tr>
<td>14</td>
<td>54965.7</td>
</tr>
<tr>
<td>15</td>
<td>61944</td>
</tr>
<tr>
<td>16</td>
<td>70709.4</td>
</tr>
<tr>
<td>17</td>
<td>82900.9</td>
</tr>
<tr>
<td>18</td>
<td>56225.7</td>
</tr>
<tr>
<td>19</td>
<td>68766</td>
</tr>
<tr>
<td>20</td>
<td>88525.2</td>
</tr>
</tbody>
</table><br />
<p>نکته: من این نمودارو با استفاده از نرم‌افزار آزاد <code>LibreOffice</code> کشیدم.</p><br />
<p>اولاً که چیزی که از نمودار مشهوده، با‌گذشت زمان کندی یه I/O ثابت روی دیسک، حین دسترسی مشترک رشد خطی میکنه، پس میتونیم برونیابی کنیم که با گذشت زمان، زمان نوشتن روی دیسک به این صورت هی کندتر و کندتر میشه، بر خلاف رم که سیر ثابتی رو طی میکنه</p><br />
<p>دوماً که میبینیم دیسک تا 50 برابر کند تر عمل کرده، اما انتظار ما این بود که دیسک خیلی خیلی کند تر بشه، اینجا بحث همون بهینه سازی های سیستم عاملی هست. سیستم عامل اجازه نمیده که یه پراسس انحصار I/O رو روی دیسک بصورت کنترات برداره و بقیه پراسسها نتونن از دیسک استفاده کنن، برای همین به نوبت از روی پردازنده برشون میداره و منابع مشترک رو تقسیم میکنه. برای اطلاعات بیشتر میتونین مساله بن‌بست در کامپیوتر (Deadlock) و انحصار متقابل (Mutual exclusion) رو مطالعه کنین. شاید بعداً ازشون حرف زدیم.</p><br />
<p>سوماً، بهینگی سیستم عاملی تمام مبحث نیست، دیسک-خورهای ما زیاد استاندارد نیستن، چهارتا پراسس هستن که توی سکتورهای متوالی دیسک دارن یه دیتای محدود و ثابتی (که قابل کش شدنه) رو مینویسین و این حرکت رو تکرار میکنن… چی میشه اگه بجای این دیسک-خورها، از یسری دیسک-خور واقعی استفاده کنیم..!</p><br />
<hr /><br />
<p>خب بسه دیگه، من همینجا آزمایش رو متوقف میکنم چون نمیخوام دیسکم بسوزه! اما این پرونده باز میمونه:</p>
<ul>
<li>چه سناریوهای دیگری رو میتونیم تست کنیم که به کندی 100,000 بار یا حتی یه 1 ملیون بار در عمل برسیم؟</li>
</ul><br />
<p>این مقاله ممکنه آپدیت بشه ^_^</p><br />
<p>تا اینجا کدهای مقاله روی یه ماشین استاندارد لینوکسی با مشخصات زیر آزمایش شدن:</p>
<pre><code>OS: Kali GNU/Linux Rolling x86_64
Kernel: 5.16.0-kali5-amd64
CPU: Intel i5-8250U (8) @ 3.400GHz
Memory: 11857MiB
Shell: zsh 5.8.1</code></pre><br />
<p><strong>HDD details:</strong></p>
<pre><code class="language-bash">duf</code></pre>
<pre><code class="language-bash">╭───────────────────────────────────────────────────────────────────────────────────────────╮
│ 2 local devices                                                                           │
├────────────┬────────┬────────┬────────┬───────────────────────────────┬──────┬────────────┤
│ MOUNTED ON │   SIZE │   USED │  AVAIL │              USE%             │ TYPE │ FILESYSTEM │
├────────────┼────────┼────────┼────────┼───────────────────────────────┼──────┼────────────┤
│ /          │ 200.2G │ 164.0G │  26.0G │ [################....]  81.9% │ ext4 │ /dev/sda6  │
│ /boot/efi  │ 512.0M │  12.5M │ 499.5M │ [....................]   2.4% │ vfat │ /dev/sda5  │
╰────────────┴────────┴────────┴────────┴───────────────────────────────┴──────┴────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────╮
│ 6 special devices                                                                              │
├────────────────┬──────┬────────┬───────┬───────────────────────────────┬──────────┬────────────┤
│ MOUNTED ON     │ SIZE │   USED │ AVAIL │              USE%             │ TYPE     │ FILESYSTEM │
├────────────────┼──────┼────────┼───────┼───────────────────────────────┼──────────┼────────────┤
│ /dev           │ 5.7G │     0B │  5.7G │                               │ devtmpfs │ udev       │
│ /dev/shm       │ 5.8G │  23.5M │  5.8G │ [....................]   0.4% │ tmpfs    │ tmpfs      │
│ /run           │ 1.2G │   1.9M │  1.2G │ [....................]   0.2% │ tmpfs    │ tmpfs      │
│ /run/lock      │ 5.0M │     0B │  5.0M │                               │ tmpfs    │ tmpfs      │
│ /run/snapd/ns  │ 1.2G │   1.9M │  1.2G │ [....................]   0.2% │ tmpfs    │ tmpfs      │
│ /run/user/1000 │ 1.2G │ 192.0K │  1.2G │ [....................]   0.0% │ tmpfs    │ tmpfs      │
╰────────────────┴──────┴────────┴───────┴───────────────────────────────┴──────────┴────────────╯</code></pre>
<pre><code class="language-bash">sudo hdparm -I /dev/sda6</code></pre>
<pre><code class="language-bash">/dev/sda6:

ATA device, with non-removable media
        Model Number:       HGST HTS541010B7E610                    
        Serial Number:      WXF1E673XX4S
        Firmware Revision:  03.01A03
        Transport:          Serial, SATA 1.0a, SATA II Extensions, SATA Rev 2.5, SATA Rev 2.6, SATA Rev 3.0
Standards:
        Used: unknown (minor revision code 0x006d) 
        Supported: 10 9 8 7 6 5 
        Likely used: 10
Configuration:
        Logical         max     current
        cylinders       16383   0
        heads           16      0
        sectors/track   63      0
        --
        LBA    user addressable sectors:   268435455
        LBA48  user addressable sectors:  1953525168
        Logical  Sector size:                   512 bytes
        Physical Sector size:                  4096 bytes
        Logical Sector-0 offset:                  0 bytes
        device size with M = 1024*1024:      953869 MBytes
        device size with M = 1000*1000:     1000204 MBytes (1000 GB)
        cache/buffer size  = unknown
        Form Factor: 2.5 inch
        Nominal Media Rotation Rate: 5400
Capabilities:
        LBA, IORDY(can be disabled)
        Queue depth: 32
        Standby timer values: specd by Standard, with device specific minimum
        R/W multiple sector transfer: Max = 16  Current = 16
        Advanced power management level: 254
        DMA: mdma0 mdma1 mdma2 udma0 udma1 udma2 udma3 udma4 udma5 *udma6 
             Cycle time: min=120ns recommended=120ns
        PIO: pio0 pio1 pio2 pio3 pio4 
             Cycle time: no flow control=120ns  IORDY flow control=120ns
Commands/features:
        Enabled Supported:
           *    SMART feature set
                Security Mode feature set
           *    Power Management feature set
           *    Write cache
           *    Look-ahead
           *    WRITE_BUFFER command
           *    READ_BUFFER command
           *    NOP cmd
           *    DOWNLOAD_MICROCODE
           *    Advanced Power Management feature set
                Power-Up In Standby feature set
           *    SET_FEATURES required to spinup after power up
           *    48-bit Address feature set
           *    Mandatory FLUSH_CACHE
           *    FLUSH_CACHE_EXT
           *    SMART error logging
           *    SMART self-test
           *    General Purpose Logging feature set
           *    64-bit World wide name
           *    IDLE_IMMEDIATE with UNLOAD
           *    {READ,WRITE}_DMA_EXT_GPL commands
           *    Segmented DOWNLOAD_MICROCODE
           *    Gen1 signaling speed (1.5Gb/s)
           *    Gen2 signaling speed (3.0Gb/s)
           *    Gen3 signaling speed (6.0Gb/s)
           *    Native Command Queueing (NCQ)
           *    Host-initiated interface power management
           *    Phy event counters
           *    Idle-Unload when NCQ is active
           *    NCQ priority information
           *    READ_LOG_DMA_EXT equivalent to READ_LOG_EXT
           *    DMA Setup Auto-Activate optimization
           *    Device-initiated interface power management
           *    Software settings preservation
           *    SMART Command Transport (SCT) feature set
           *    SCT Write Same (AC2)
           *    SCT Features Control (AC4)
           *    SCT Data Tables (AC5)
                unknown 206[12] (vendor specific)
                unknown 206[13] (vendor specific)
           *    Extended number of user addressable sectors 
           *    DOWNLOAD MICROCODE DMA command
           *    WRITE BUFFER DMA command
           *    READ BUFFER DMA command
           *    Data Set Management TRIM supported (limit 10 blocks)
           *    Deterministic read data after TRIM
Security: 
        Master password revision code = 65534
                supported
        not     enabled
        not     locked
        not     frozen
        not     expired: security count
                supported: enhanced erase
        180min for SECURITY ERASE UNIT. 180min for ENHANCED SECURITY ERASE UNIT.
Logical Unit WWN Device Identifier: 50014ee608088121
        NAA             : 5
        IEEE OUI        : 0014ee
        Unique ID       : 608088121
Checksum: correct</code></pre><br />
<hr /><br />
<p>یکسری لینک پرسش و پاسخ مرتبط با این موضوع:</p>
<ul>
<li><em><a href="https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access">https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access</a></em></li>
<li><em><a href="https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk">https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk</a></em></li>
<li><em><a href="https://queue.acm.org/detail.cfm?id=1563874">https://queue.acm.org/detail.cfm?id=1563874</a></em></li>
</ul><br />
<p>و تمام، هارددیسک بطور متوسط 100000 بار از رم کند تره:))</p><br />
<h2>کارهای آینده</h2><br />
<p>شما توی مقاله خودتون میتونین روی سناریوهایی کار کنین که کندی بیشتری رو به تصویر بکشین، میتونین از دیسکهای مختلف استفاده کنین یا حتی از کلاسترهای مختلف روی RAID های مختلف استفاده کنین.</p><br />
<h2>کپی رایت</h2><br />
<p>این یک مقاله آزاد و متن‌باز تحت مجوز GFDL1-3 می‌باشد، بنابراین اجازه کپی، توزیع و/یا تغییر این سند با شرایط مجوز GNU Free Documentation License داده شده است.</p><br />
<h2>منابع</h2>
<ul>
<li><a href="https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm">https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm</a></li>
<li><a href="https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041">https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041</a></li>
<li>Database System Concepts, 6th Edition</li>
<li><a href="http://www.foundersatwork.com/steve-wozniak.html">http://www.foundersatwork.com/steve-wozniak.html</a></li>
<li><a href="https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90">https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90</a></li>
<li><a href="https://blog.codinghorror.com/understanding-user-and-kernel-mode">https://blog.codinghorror.com/understanding-user-and-kernel-mode</a></li>
<li><a href="https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys">https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys</a></li>
<li><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems</a></li>
<li><a href="https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine">https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine</a></li>
<li><a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></li>
</ul></div><script src="https://tadavomnist.github.io/assets/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://tadavomnist.github.io/assets/js/MathJax.js" type="text/javascript"></script><script type="text/javascript">MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});</script><script>document.addEventListener("DOMContentLoaded", ev => document.body.querySelectorAll("#container > *").forEach(elm => elm.setAttribute("dir", "auto")));</script><script>const toggleButton = document.getElementById("dark-mode-toggle");const container = document.getElementById("container");const body = document.body;if (toggleButton.checked) {enableDarkMode();}toggleButton.addEventListener("click", () => {if (!toggleButton.checked) {disableDarkMode();} else {enableDarkMode();}});function enableDarkMode() {body.classList.add("dark-mode");localStorage.setItem("darkModeEnabled", true);}function disableDarkMode() {body.classList.remove("dark-mode");localStorage.removeItem("darkModeEnabled");}</script></body></html>