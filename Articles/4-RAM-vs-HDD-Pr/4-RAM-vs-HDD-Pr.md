# مقایسه سرعت خوندن/نوشتن RAM و HDD 
## چکیده
توی این مقاله به تفصیل راجع به سرعت خوندن/نوشتن اطلاعات روی رم و روی هارددیسک صحبت میکنم، برای این منظور ابتدا تکنولوژی زیر باک رم و زیر باک هارددیسک رو توضیح میدم، بعدش به این موضوع میپردازم که بخاطر پیچیدگی های تکنولوژیک، متوسط سرعت خوندن/نوشتن توی هر کدوم چقدره و با هم مقایسه‌شون میکنم.

## چرا میخوایم سرعت رم و هارد دیسک رو مقایسه کنیم؟

RAM vs HDD

چند سال پیش توی یه فرومی توی یه تایپیکی مربوط به برنامه‌نویسی من به این نکته اشاره کردم که سرعت خوندن/نوشتن توی هارددیسک بطور متوسط 100 هزار بار از رم کمتره..!
برای بسیاری از برنامه‌نویسها این حرف عجیب بود، و خیلیا قبولش نمیکردن، برای همین من مجبور شدم تکنولوژی هر دو رو توضیح بدم و با زبان تخصصی بگم که چرا چنین حرفی زدم.
با این مقاله همراه باشین تا ببینیم چرا میگم هارد دیسک بطور متوسط صد هزار بار از رم کند تره.

اولا که واضحه هیچوقت نمیتونیم همچین چیزیو بطور دقیق بگیم، هر کسی ادعا کنه که مثلاً HDD دقیق انقدر از RAM سریع تره ، معلومه که خیلی چیزارو نمیدونه.

دوما ، مقایسه هارد دیسک و رم عمرا توی یک مقاله بگنجه:)
من میتونم یک کتاب چند جلدی راجع به RAM بنویسم و یک کتاب چند جلدی راجع به HDD و توی یک کتاب چند جلدی اینارو با هم مقایسه کنم! نه بخاطر اینکه من خیلی عالم هستم ، بلکه بخاط اینکه متوجه بشین حجم و عمق مطلب خیلی زیاده .
اینجوری نیست که ما بگیم آره سرعت این موجودیت رو توی اینترنت نوشته انقدر و سرعت اونو نوشته فلانقدر و بقیه‌ش یه تقسیم ساده‌ست، .....

بلکه این مطلب میتونه بعنوان تز دکتری توی تحصیلات عالیه مطرح بشه، و یک نفر پایانامه دکتراشو صرف این کنه و یه مقاله بنویسه، که بازم نمیتونه کل مطلب رو ادا کنه..

اینارو صرفا عرض کردم که بدونین چقدر ماجرای عمیقیه...😬❤️
بیشتر مطالبی که راجع به هارددیسک بیان میکنم رو من چندین سال قبل از کتاب استاد آبراهام سیلورچتس خونده بودم. اسم کتاب هست:
* Database System Concepts, 6th Edition

## رم چیست؟
رم – RAM – مخفف Random Access Memory هست یعنی حافظه ای با دسترسی تصادفی، خود این اسم تمام ساختاری که لازم هست راجع به رم بدونیم رو توضیح میده. فرض کنید یه تیکه حافظه گنده دارید که سرعتش نسبتا بالاست (نسبت به تکنولوژیهایی مثل دیسک و ای2پیرام) و شمای انتزاعیش همچین چیزیه:


![Abstract RAM schema](Files/1.png)

_مدل انتزاعی یک رم_


هر خونه‌ش رو یک بایت فرض کنید، n تا بایت پشت سر هم که میتونید با سرعت نسبتاً بالا توش اطلاعات رو ذخیره کنید. این سرعت بالا به سیستم عامل این امکان رو میده که جایی داشته باشه که با سرعتی معقول اطلاعات محاسبات فعلیش رو ذخیره سازی کنه.


اما چرا سرعتش بالاست؟

از لحاظ پیاده‌سازی سخت افزاری، این حافظه روی یه آرایه دو بعدی مدل شده،‌ مثل یه ماتریس. ساختار «Random Access» این امکان رو ایجاد میکنه که ما به تمام خونه های مختلف حافظه در یک زمان یکسان دسترسی داشته باشیم، اما چطور؟
بیاین ساختار بلوک منطقی رم رو نگاه کنیم:

![RAM Logical structure](Files/2.png)

_یک رم 8 بیتی - منبع عکس [ETSU](https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm)_

امروزه رم ها از خونه‌های کوشولویی که توی یه آرایه دو بعدی هستن تشکیل شدن. هر رم یک واحد Address-Decoder داره که آدرسی انکد شده در مبنای 2 (باینری) رو دریافت میکنه و اون رو دیکد میکنه که ببینه کدوم سلول حافظه باید انتخاب بشه (برای خوندن/نوشتن).
توی همین عکس یه واحد منطقی Read/Write داریم که کارش اینه که خبر بده آیا باید چیزی نوشته بشه یا باید چیزی خونده بشه.
همچنین یه واحد دیگه هم وجود داره به اسم Cheap-Select ، این برای موقعی هست که ما بیش از یک چیپ مموری داریم (در واقعیت اینجوریه).
همچنین ساختاری به نام databus وجود داره که توش 0 با ولتاژ پایین و 1 با ولتاژ بالا نشون داده میشه، این قسمت ورودی/خروجی سلول‌های چیپ رم هست.
همچنین فرض کنید سطرهای رم 8 بیتی یا 1 بایتی هستن.

فرض کنید شما میخواین توی خونه هزارم (1000) رم بنویسین، برای این حداقل یک آدرس دیکودر 10 بیتی لازم دارین ( چون 2 به توان 10 میشه 1024 و با یک آدرس دیکودر 10 بیتی میشه بین 1024 تا خونه رم تمییز قائل شد و آدرسدهی کرد). حالا شما 1000 در مبنای 10 رو میبرید به مبنای 2 که میشه : 1111101000 
و این عدد آدرس باینری 1111101000 رو میفرستید به آدرس-دیکودر. آدرس-دیکودر با گیتهای منطقی درونی که داره، با گرفتن  1111101000 به عنوان ورودی، سطر هزارم رم رو انتخاب (select) میکنه و خوندن/نوشتن اتفاق می‌افته.
دقیقاً فرقش با یه تکنلوژی مثل دیسک همینه...، توی دیسک باید یکسری خونه پیمایش بشن تا برسیم به خونه مد نظر، اما اینجا یه مدار منطقی داریم که آدرس-دیکودر مدار خاصیش رو روشن میکنه. صرفاً اون مدار انتخاب میشه و نه تنها حرکت فیزیکی نداریم (در مقایسه با دیسک) بلکه پیمایش خونه به خونه هم نداریم (در مقایسه با دیگر تکنولوژیها) 
یک آدرس-دیکودر 3 بیتی توی شکل زیر نشون داده شده، حتماً در جریانید که با 3 بیت میشه 2 به توان 3 یعنی 8 حالت مختلف داشته باشیم. پس یه آدرس دیکودر 3 بیتی میتونه 8 خونه از رم رو آدرسدهی کنه و همرو با یک سرعت یکسان انتخاب کنه.


![3-bit Address-Decoder](Files/3.png)

_یک آدرس دیکودر 3بیتی با 8 پایانه- منبع عکس [Codestall](https://codestall.wordpress.com/2017/09/02/532-decoder-design-using-4-38-decoders-and-1-24-decoder-in-verilog/)_



یک آدرس-دیکودر 10 بیتی هم عین همین ساخته میشه، و میتونه 1024 تا سطر مختلف رو انتخاب کنه، فقط شکلش توی این مقاله جا نمیشه:))

پس این شد معنی ساختار «دسترسی تصادفی» یا «Random Access»، یعنی زمانی که ما یک طراحی سخت‌افزاری داریم که اوردر زمانی دسترسی به هر سلول حافظه ما با بقیه سلولها برابره، این اتفاق با پیاده‌سازی یه گیت منطقی ممکن میشه که بهش میگیم آدرس-دیکودر و توضیحش دادیم.

اگر سرعت دسترسی اینقدر عالی و خوبه، چرا ما RAM رو جایگذین یچیزی مثل دیسک نمیکنیم و ازش استفاده نمیکنیم؟
رم بخاطر ساختار منطقی و الکترونیکی که داره، با قطع شدن جریان برق، تمام اطلاعات داخلش پاک میشه و اصطلاحاً تمام اطلاعاتش ریست میشه(بیتهاش 0 میشه).
این در مقابل دیسک، نمیتونه یه حافظه استیبل برای ذخیره سازی طولانی مدت باشه...، صرفاً برای ذخیره اطلاعات فعلی محدود به محاسبات کامپیوتر خوبه.

این روزها حافظه هایی مثل SSD که حرکت فیزیکی ندارن دارن به جای چیزهایی مثل HDD در بعضی جاها استفاده میشن – اونا بخاطر نداشتن حرکت فیزیکی بسیار سریع ترن – اما مشکلات خودشونم دارن. شاید در آینده توی یه مقاله جدا اون تکنولوژیهارو هم بررسی کردیم.


برگردیم به رم، از لحاظ تکنولوژی ساخت رم ها به دو دسته استاتیک و داینامیک تقسیم میشن.

* رمهای استاتیک (SRAM):

رمهای استاتیک اطلاعات رو توی مدارهای ترانزیستوری شبیه D-فلیپ فلاپ ذخیره میکنن، و این اطلاعات مادامی که رم برق داشته باشه اونجا میمونن و از بین نخواهند رفت. نسبت به رم های داینامیک کوشولوتر هستن و سرعتشون بیشتره و دیکودر ساده‌تری دارن. معمولاً توی فرایندهای سرعتی مثل کش کردن و اپلیکیشنهای خیلی سریع استفاده میشن.
بعضی جاها که میخوان اطلاعات مهم رو روی رم نگه دارن، از همین SRAM استفاده میکنن و یه باتری بک‌آپ به مدار اضافه میکنن که حتی اگه به هر دلیلی برق مدار قطع شد، باتری سیستم رو تغذیه کنه و اطلاعات پاک نشه.

* رمهای داینامیک (DRAM):

رمهای داینامیک اطلاعات رو رو خازنها ذخیره میکنن. این خازنها بخاطر ساختار کوشولوتری که دارن ظرفیت کلی رم رو میرن بالا، اما این خازنها یه مشکل بزرگ دارن، هر خازن طبق طبیعت الکترونیکش بعد از مدت زمانی جریان داخلی خودش رو از دست میده و اصطلاحاً دِشارژ میشه. بعد از  دِشارژ شدن یه خازن اطلاعاتی هم که توش ذخیره شده بوده میپره! به این روند میگن leak شدن جریان برق. برای جلوگیری از - از دست رفتن اطلاعات، باید تند-تند اطاعات کل خازنها خونده بشن و دوباره همونجا نوشته بشن که خازنها شارژ بمونن و اطلاعات از دست نره. به این روند میگن refresh کردن مدار. پس توی DRAM ها باید یه مدار ریفرش-کننده باشه که اطلاعات همه خازنهارو هی تند-تند بخونه و هی تند-تند دوباره سر جاشون بنویسه.
ضمناً رمهای داینامیک خیلی از رمهای اساتیک ارزونتر هستن، و رمهایی که روی سیستم شما الان دارن استفاده میشن احتمالاً دینامیک هستن.

بهتون پیشنهاد میکنم مصاحبه استیو ووزنیاک رو حتماً مطالعه کنین، این مصاحبه علیرغم اینکه قرار بوده مصاحبه محاوره ای و معمولی نسبت به خودش شخص ووز باشه، توش بینهایت توضیحات تخصصی الکترونیکی داره..!
یه قسمتش راجع به تکنولوژی رمها حرف میزنه که خیلی جالبه:

_«...به اطرافم نگاه کردم، اولین رم دینامیک همون سال معرفی شده بود. 1975 اولین رم دینامیک 4کلیوبایتی به بازار اومده بود. این اولین بار بود که قیمت رم از قیمت حافظه‌های مغناطیسی، که تا امروز در همه جا استفاده میشد کمتر بود. حالا ناگهان دنیا داشت به سمت رم میرفت، حافظه ما از این به بعد روی سیلیکون بود. تقریبا همه در جهان، آلتیر – شفر کامپیوتر – پلیمرفیک کامپیوتر – اینسایت کامپیوتر و ...، با مهندسهایی ناکارآمد و نه بهترین مهندس های موجود طراحی میکردن. اونها تکنسینهایی بودن که میدونستن باید چطور دیتاشیت رمهارو بخونن و بعد توی دیتاشیت ریزپردازنده‌ها دنبال خطی بگردن که توش نوشته شده آدرس، و اونو با آدرس رم تطبیق بدن و سیمکشی کنن. این کار ساده ایه، اما فقط در صورتی کار میکنه که رمهای شما استاتیک باشن. رمهای دینامیک قیمتی برابر نصف یا حتی یک چهارم قبلیا داشتن. معنی رم دینامیک این بود که به جای داشتن 32 تراشه برای ساخت کامپیوتری که زبون بفهمه، میتونستین 8 تراشه رم داشته باشین. اما رم دینامیک به مدارهایی نیاز داشت که در هر ثانیه 2000 بار به تک تک آدرسهاشون سر بزنن و چیزی که اونجاست رو بخونن و دوباره اونارو همونجا بنویسن تا اطلاعات از دست نره! رم دینامیک که امروز هم در کامپیوتر ما وجود داره هر بیتی رو فقط در دوهزارم ثانیه فراموش میکنه مگر اینکه یه نفر اون بیت رو توی این زمان بخونه و دوباره سر جاش بنویسه. میشه اینطور گفت که الکترون ها توی بشقابین که در هر 2هزارم ثانیه ازش میریزن بیرون..!»_

ترجمه از استاد جادی، کل مصاحبه به زبان فارسی:
https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90

اصل مصاحبه:
http://www.foundersatwork.com/steve-wozniak.html


و دیگه تقریباً تمام مسائل تکنیکی که میخواستم راجع به رمها بگم رو گفتم، مدیریت یک رم بر عهده سیستم عامله. CPU کامپیوتر با Virtual-Addressing کار میکنه و خود رم با Logical-Addressing. 
بعداً یه مقاله جدا راجع به اینکه سیستم عامل چه‌جوری رم رو به پراسسها تخصیص میده مینویسم و یه مقاله جدا هم مینویسم راجع به اینکه چطور میتونیم به کل رم فعلی سیستم دسترسی داشته باشیم.


## هارددیسک چیست؟

دیسکها، لوحهای گرد و دایره‌ای شکلی هستن که میتونن بسته به معماریشون اطلاعات رو توی خودشون ذخیره کنن، اولین نوع دیسکهارو میتونیم توی گرامافونها ببینیم، که اونجا صدای ورودی به گرامافون باعث ایجاد لرزه میشد و سوزن روی لوح گردی که میچرخید یه شیاری رو بصورت حلزونی ایجاد میکرد. برای پخش صدا سوزن نرم تری میذاشتن که توی شیار حرکت میکرد و با استفاده از لرزش صدارو بازپخش میکرد.
بعدها دیسکهای سخت مغناطیسی اومدن که ازشون میخوایم حرف بزنیم و همینطور دیسکهای نوری مثل CD ها و DVDهارو داشتیم که با یک لیزر توشون اطلاعات burn میشد.
پس دیسک به طور کلی توی این حوزه،‌معمولا لوح گردی هست که حول یه محوی میچرخه و اطلاعات توی شعاع های مختلف اون نوشته میشه.


یه هارددیسک، شامل دیسکهای گرد مغناطیسی هست که اطلاعات توش با مغناطیسه شدن هر ذره کوشولو از دیسک، بصورت باینری نوشته میشه. هارددیسک معمولا از چند تا لایه (پلاتر-platter) تشکیل شده، تعداد این پلاتر ها معمولا بین 1 تا 5 تا هست.
اگه بصورت یه برش عرضی ببینیم این شکلی میشه:

![HDD Platters](Files/4.jpg)

_منبع عکس [compuclever](https://www.compuclever.com/posts/hard-disk-drive-basics/ic306536/)_



همون برش عرضی بصورت انتزاعی:

![HDD Abstract Platters](Files/5.jpg)

_منبع عکس: کتاب Database System Concepts, 6th Edition_


حالا این پلاتر ها، یه سطح مغناطیسی هستن که میتونن با مغناطیسه شدن، 0 و 1 هارو توی خودشون ذخیره کنن.
این پلاتر، به شکل منطقی (logical) به یسری شعاع های متفاوت تقسیم میشه، که این شعاعها شامل دایره‌های گردی هستن که دیسک رو میسازن، به هر کدوم از این شعاع ها میگن یه ترک- Track
توی عکس زیر چندین ترک انتزاعی رو میبینید:

![HDD Tracks](Files/6.jpg)

_منبع عکس [schoolcoders](https://www.schoolcoders.com/memory-storage/secondary-storage/hdd/)_


خود این ترک به قسمتهای کوچکتری تقسیم میشه، که بهش میگن سکتور- sector
توی عکس زیر قسمت سکتور رو مشاهده میکنید:

![HDD Sectors](Files/7.jpg)

_منبع عکس [slideplayer](https://slideplayer.com/slide/1517076/)_

یه سکتور کوچکترین واحدی توی دیسک هست که نوشته/خونده میشه، معمولا سایز یه سکتور 512 بایت هست...

یه دسته‌ای هم توی یه هارددیسک وجود داره که بهش میگن arm که سرش یه هد (head) داره که عقب جلو میره و خود دسته هه هم میچرخه و این سکتورهارو میخونه یا توشن مینویسه.

منطقا ترکهای بیرونی(شعاع های بزرگتر) تعداد سکتورهای بیشتری از ترکهای درونی(شعاعهای کویچکتر) دارن..

هر نوع اطلاعاتی که بخواد روی دیسک نوشته بشه، باید بصورت 0 و 1 نوشته بشه، یعنی بصورت باینری انکد بشه، و به آرم  داده بشه که توسط هد توش نوشته بشه. همین داستان برای خوندن هم بر قراره.
بسته به فرمتهای مختلف نرم افزاری که هارددیسکهارو با اونها فرمت میکنیم، یکسری تکنولوژی نرم‌افزاری وجود دارن که مربوط به بحث ذخیره سازی داده‌ها هستن مثل inode و mft که بعداً توی مقالات دیگه راجع بهشون حرف میزنیم.



## مقایسه سرعت هارددیسک و رم


فرض کنید تمام پیچیدگی های پیاده سازی و عملیاتی و سیستم عاملی رم رو نادیده بگیریم ، و یه راست بریم سراغ هارد دیسک:

وقتی سرعت یک هارد دیسک رو میخوایم در نظر بگیریم ، باید سرعت متوسط اعمال I/O رو توی اون در نظر بگیریم یعنی ورودی خروجی های هارد دیسک
*Input/Output
یا به زبان فارسی ساده : خوندنها و نوشتن‌ها

محاسبه این سرعت بشدت کار تخصصی هست و توی این سرعت هزاران فاکتور دخیله، فاکتور هایی که هر کدوم توضیح دادنشون یک کتابه مطلبه و نهایتا اگر تمام فاکتور هارو بتونیم مدلسازی کنیم ، (که خیلی کار سختیه) در سناریو های مختلف ممکنه از 10 هزاربار تا مثلا 500 هزار بار کند تر عمل کنه. که متوسط این سناریو هارو بعنوان آمار بیان میکنن.

یک هارد دیسک ، مثل یک CD یه (چند تا) دیسک داره که میچرخه و یک هد داره (مثل اون دسته سیاهای توی گرامافون) که روی یه مداری که روی شعاع دیسک واقع شده میتونه بالا و پایین بره. به این ترتیب میتونه تمام دیسک رو پردازش کنه.

گیف پایین رو مشاهده بفرمائید:

![HDD head move](Files/8.gif)

_یادم نمیاد منبع گیف کجاست- اگر میدونید خبر بدین!_

______________________________________

یک سرعتی برای هارد دیسک بیان میشه بعنوان Transfer time که مجموعه کلی‌ای از چند تا سرعت هست وابسته به فاکتور های زیر :

1 - سرعت خوندن هد {سرعت خوندن دیتا توسط هد ، باز خودش وابسته هست به 7-8 تا فاکتور! ما میگیم که متفاوته و ریزتر نمیشیم}

2 - سرعت بالا و پایین شدن هد

3 - سرعت چرخش دیسک {در هارد دیسکهای متفاوت‌، این سرعت متفاوت هست}

4 - ظرفیت ترک (track)

5 - ظرفیت سکتور

6 - مقدار دیتای طلب شده

7 - تاخیر چرخشی (این با سرعت چرخش فرفق میکنه ) بهش میگن Rotational Latency
(من یکمی توی همین مقاله توضیحش میدم ولی خیلی بیشتر از این مطلب لازم داره، توی کتابی که معرفی کردم خیلی خوب توضیح داده)

8 - تاخیر seek کردن هد یا seek time
( اینم جلوتر من یکمی توضیحش میدم )

9 - بلاک اینترلیود بودن هارد دیسک (اینو بعدش توضیح میدم و میگم که چه فرقی با رم داره که رم بایت اینترلیود هست - این خیلی جالبه) 

10 - تکنیک جلو-جلو خوندن هارددیسک یا read ahead 
(اینم باید توضیح بدم)

11 - ظرفیت اتخاذ شده برای تکنیک بافرینگ Buffering. 
(اینم باید توضیح بدم)

12 - الگوریتمهای زمانبندی روی هارد دیسک! این مطلب خودش میتونه یه کتاب 12 جلدی باشه! من واقعا نمیدونم چجوری میتونم حق مطلب رو توی این مقاله ساده بیان کنم! زبان من الکن هست از توصیفش - مثلا من اگه میشد الگوریتم آسانسورو برای شما شرح بدم که ببینین اگر نبود هارددیسک یک ملیارد بار کند تر میشد...!

13 - نحوه چینش فایلها!!! این دیگه واقعا خیلی خییلی خیلی خیلی توضیح میطلبه!!! شما قطعا از فرگمنت شدن دیسک اسمشو شنیدین ، شاید فقط شنیدین که دیسک دیفرگ بشه سرعتش میره بالا... شایدم میدونین معنیش چیه... حالا توضیحش میدیم😬

14 - نحوه ذخیره سازی لاگها روی هارد دیسک - که من راجع بهش چیزی نمیگم

15 - کش کردن درخواستها توسط سیستم عامل که از اسکیل بحث ما خارجه

16 - بحث دیوایس منیجینگ یا به قول ویندوزی ها درایو منیجینگ که بشدت تخصصیه و کار من نیست توضیحش

17 - ... انقدر فاکتور در این سرعت دخیل هست که من اگه بخوام بگم شاید هیچوقت نتونم این مقاله رو ببندم، همه بحثهاشم من بلد نیستم* بسیار بسیار تخصصی هست ، باید مراجعه کنید به خبره های فایل سیستم، من اطلاعات خیلی ناکامل محدود و اندکی دارم.

حالا زمان اتقال یا ترنسفر تایم، - که اول گفتم - میشه جمعِ تمــــــام این تاخیر ها و زمانهای موجود!

______________________________________


حالا بریم سراغ توضیح قسمتهایی که گفتم، شروع کنیم از توضیح دو مورد اول که خیییلی باحال و مهمه:

رم مستقل از حرکات فیزیکیه اما هارددیسکها اتلاف زمان/انرژی توی حرکت فیزیکی دارن. 

دو اتلاف وقت مشهور فیزیکی در هارددیسک: 

1 - هارد دیسکها یه اتلاف دارن موقع چرخیدن خود دیسک 💿
مثلا یه داده ای که میخوای بخونی یا بنویسی ، توی این درجه از دیسک نیست(درجه ای که هد روی اون قرار داره) و مثلاً دیسک باید 260 درجه بچرخه تا توی اون درجه بخصوص بیفتته!
بهش میگن:
* rotational latency time

2 - یک اتلاف وقت دیگه دارن اینکه اون سیخسیخک هارد که بهش میگن هد (head) باید بالا و پایین بره و دقیق روی شعاع مربوطه بیفته تا بتونه سکتورو پیدا کنه ، بهش میکن زمان بالا پایین شدن برای جستجو یا 
* seek time


همین دوتا حرکت فیزیکی کافیه تا هارد دیسک بشدت کند باشه و نشه ازش بجای یچیزی مثل رم جهت ذخیره‌سازی سریع اطلاعات محاسبات فعلی استفاده کرد، ولی خوبیش اینه که اطلاعات با قطع شدن برق از بین نمیرن:3

عکس زیرو ببینین:

![seek-time vs rotational-latency-time](Files/9.jpg)

_یادم نمیاد منبع این عکس هم کجاست- اگر میدونید خبر بدین!_


راستیه روتیشنال لیتنسی تایمه،
زمانی که دیسک باید بیکار وایسته تا دیسک بچرخه و اول سکتور مورد نظر بیاد.

چپیه سیک-تایمه،
زمانی که باید هد حرکت کنه بره روی شعاعی که سکتور مورد نظر هست.

______________________________________


**بلاک اینترلیود بودن هارد دیسک:**

ما چند نوع اینترلیوینگ (معماری کار با بخشی از داده) داریم :

* معماری bit-interleaved:
یعنی که اطلاعات بیت بیت از یک حافظه ای خونده بشه
* معماری byte-interleaved:
یعنی که اطلاعات بایت بایت از یک حافظه ای خونده بشه
* معماری block-interleaved:
یعنی که اطلاعات بصورت چانکهایی که 1 بلاکه هست از هارد دیسک خونده بشه - سایز این بلاک رو سیستم عاملها مشخص میکنن.

حالا فرقش چیه؟
قدیما اون اوایل که کامپیوتر ساخته شده بود میومدن یه بیت یه بیت میخوندن اطلاعاتو ، طبیعیه که خیلی کار بیخودیه ، چون تمام اطلاعاتی که ما باهاشون کار میکنیم حداقل یه بایت میطلبن
پس معماری بایت اینترلیود مطرحش شد و به کار گرفته شد…

امروزه شما نمیتونی یه بیت اطلاعات بنویسی توی دیسک یا روی رم یا تقریبا هر حافظه ای، باید حد اقل یک بایت بنویسی،
مثلا واسه یه متغیر بولین (TRUE/FALSE) فقط یه بیت کافیه ، اما همیشه 8 بیت میگیرن ، چونکه جنس حافظه بایت اینترلیود هست:)

حالا توی هارد دیسکها اومدن بلاک اینترلیود بودنو مطرح کردن ، وقتی طرف یه سیستم-کال میزنه به هارد دیسک و میگه که فلان بایت رو به من بده ، هارد دیسک میگه که من این همه دیسک بچرخونم هد بالا پایین کنم واسه یه بایت ؟! خب اگه بر فرض تو بعدش بگی بایت بعدیشم بده ، من دوباره باید برم هی دیسکو بچرخونم بایت بعدیشو پیدا کنم؟!
من مسخره تو نیستم! یه بلاک داده بهت میدم ، تو هر چقدرشو نیاز داری واکشی کن ، اگه بیشترم میخوای که بوگو!
مثلا 1024 بایت میده به سیستم عامل ، حالا سیستم عامل خودش فقط بایت اولشو میخواد ، میکشه بیرون و بقیه رو میریزه دور...
این قضیه الکی نیست ، روش 20 سال فکر شده و هزاران نفر آزمایش کردن و فهمیدن بلاک اینترلیود بودن بهتره از بایت اینتر لیود بودن برای HDD ها

حالا قضیه اینطوریه که رم byte-interleaved هست و هارددیسک block-interleaved

این قضیه خودش یک دنیا سرعتو HDD رو از رم کندتر میکنه در مقایسه.

______________________________________


**تکنیک جلو-جلو خوندن هارددیسک یا read ahead :**

این تقریبا یه مفهومی شبیه چیزی که الان قبلش توضیح دادم داره ولی یه دنیا متفاوته!

مثلا هارد دیسک بر اساس رفتار میفهمه که سکتور هایی که پیاپی هستن، ممکنه نیازمند کاربر (سیستم عامل ) بشن، پس درسته که سیستم عامل نگفته که اون عداد بلاک رو به من برسون، ولی هارد دیسک میرسونه، که اگه به کارش اومد، دوباره نخواد سیستم کال بزنه و دستوراتش بره واسه درایور سخت افزار، و موتور هارد دیسک روشن بشه ، و بره جدول ذخیره سازیو دوباره بخونه، شماره سکتورو بفهمه بچرخونه و هد رو بالا پایین کنه ، و بطور مغناطیسی بخونه و برگردونه و......🥴
این الگوریتمهاش پیچیده هستن، میشه راجع بهش هزاران آزمایش کرد و هزاران الگوریتم ارائه داد...

______________________________________


**ظرفیت اتخاذ شده برای تکنیک بافرینگ Buffering:**

بافر در علم کامپیوتر یعنی یه حافظه موقت.
اینکه بافرینگ HDD چیه ، واضحه یه تیکه حافظه توی رمه که اطلاعاتی که از هارددیسک واکشی شده و اومده توش نشسته تا یه فکری به حالش گرفته بشه.
اما این ظرفیت بافر کردنه خیلی متفاوته در سیستم عاملها، همین ظرفیت سرعت رو خیلی متاثر خودش میکنه...
من بیشتر از این واردش نمیشم ، از اساتید سیستم عامل باید سوال بشه :3

______________________________________


**الگوریتمهای زمانبندی روی هارددیسک:**

بعضیها تصورشون اینه که در هر لحظه فقط یک عمل I/O برای هارد دیسک میره،
ولی فی الواقع ، در هر لحظه که با هارد دیسک تراکنش داریم ، هزاران هزار درخواست میره که بعضی هاشون درخواست نوشتن هستن و بعضی هاشون درخواست خوندن...

هارد دیسکها فقط یه هد دارن و یه دیسک ( اون سه لایه ها مد نظر ما نیست - اونا هر کدوم یه هارد دیسک حساب میشن ) وقتی یه هد داریم و یک دیسک طبیعیه که باید اسکجولینگ خیلی خفنی پیاده کنیم، تا بتونیم درخواست های داده شده رو کاملا ارضا کنیم.

اسکجولینگ خیلی خیلی مبحث پیچیده ای هست ، جدیا از بحث های سیستم عاملیش و نرم افزاریش، باید الگوریتم های سخت افزاری خفنی داشته باشیم تا بتونیم حرکاتمونو بیشتر بهینه کنیم.

مثلا الگوریتمی وجود داره به اسم الویتور یا آسانسور، که میگه که حالا که دیسک داره میچرخه و روی این سکتور ها هستی، این بلاکم بده مال درخواست سوممونه تا برسیم به سکتور درخواست اول - یا اینکه حالا که داریم اینوری سیک میکنیم روی هد همینو سیسک کن و برنگرد عقب که ادامه رو بخونی ، همونو ادامه بده درخواست پنجم روی اون نواره ، بعدا موقع برگشت دستور اولم میخونیم.

مثل یک اسانسوری که داره میره بالا و طبقه 16 عه داره میره طبقه 20 ، یکی که طبقه 1 باشه دکمه رو بزنه نمیاد پایین سوارش کنه و بعدا بره 20! میره طرف 20 رو سروار میکنه بعدا میاد 1 - اینو وسط یکی طبقه 2 هم باشه سوارش میکنه.
راجع به آسانسور به تنهایی میشه کتاب نوشت …:))

هزاران الگوریتم دیگه وجود دارن!
یک بحث بهینه‌سازی خیلی شاخی داره*-*

که اگه این بحثها نبودن واسه یه I/O زدن روی دیسک باید 70 سال منتظر مینشستیم.

______________________________________


**نحوه چینش فایلها (داده ها):**

این شاید مهم ترین بحثه ...
هیچوقت نمیشه از دیسک بعنوان مموری پردازشی استفاده کرد‌، چون نحوه چینش داده هاش خیلی خیلی سخته...

*یه مقاله هم راجع به ریکاوری مینویسم؛ اونجا فرگمنت شدن دیسک رو توضیح میدم*

دیسک فرگمنت شده:

![Fragmented HDD](Files/10.jpg)

خلاصه که همیشه سرعت هایی که بر آورد میکنید باید بر اساس یک دیسک فرگمنت شده باشه ، که خودش هزاران بار ماجرا رو کندتر میکنه،
توی RAM ما فرگمنت شدن نداریم یعنی داریم؛ ولی روی سرعت به اون شکل تاثیر نداره - اصلا بیس کارش فرگمنت بودنه، رم همونطور که توضیح دادم به تمام خونه های خودش به یک زمان مساوی «دسترسی تصادفی» دسترسی داره.

خوندن اطلاعات و کار کردن با جداول روی هارددیسک (چیزهایی مثل inode یا mft) کار خیــــلی ریسورس-بر و زمان بریه.

پس خلاصه ماجرا این میشه که،
ترنسفر تایم هارددیسک که از مجموع همه مواردی که گفتم + هزار مورد مطلب دیگه تاثیر میپذیره، خیلی کند هست.
حرکت فیزیکی دیسک بقدری کند هست که با چشم قابل دیدنه !

توی رم معماری با گیت منطقی پیاده شده و سرعتش وابسته به سرعت حرکت جریان (الکترون آزاد) هست.

یه کلیپم دارم که یک کپی پبیست ساده در هارد دیسک رو بصورت اسلوموشن نشون میده،
حرکات فیزیکی هارددیسک، وقتی درش رو باز میکنیم و میبینیم😬:

https://www.youtube.com/watch?v=3owqvmMf6No


حرکتی که با چشم قابل دیدن هست و بار دوربین قابل ظبط، قطعا خیلی کند تر از سرعت حرکت الکترونهاست:)
و در کل، بطور متوسط 100 هزاربار کندتر بودن کاملا منطقی هست، اما بیاین با دانش برنامه‌نویسی که داریم، خودمون هم دست به آچار بشیم و تست کنیم ببینیم در عمل جریان چجوریه!

______________________________________


میخوایم یکسری برنامه بنویسیم که ادعایی که کردیم (کند تر بودن هارد دیسک از رم به میزان 100 هزار بار) رو تست کنیم.

زبان برنامه‌نویسی مورد علاقه من `PHP` هست، اما وقتی بحث سنجش پیچیدگی زمانی/ریسورسی الگوریتمها میاد وسط و میخوایم آزمایشهایی رو راجع به مقایسه زمان/ریسورس مصرفی متدهای مختلف انجام بدیم، من نظرم اینه که همیشه باید حدالقمدور از زبانهای برنامه‌نویسی نزدیک به سطح پایینتر استفاده کنیم. زبانهایی کامپایلری مثل `C` و `C++` همیشه به ما دسترسی بسیار بیشتر،‌ نزدیکتر و بهینه‌تری به ریسورسهایی مثل رم و دیسک میدن و همچنین بخاطر ساختار کامپایلری‌شون، کدی ترجمه شده به زبان ماشین میدن که صرفاً نقش اجرای الگوریتم رو بر عهده داره و خیلی کمتر درگیر محاسبات پرت میشن. با استفاده از این زبانها، نتیجه آزمایشهای ما متأثر از زمان/ریسورس پرتی که صرف تفسیر کد یا اجرای فرایندهای اجرایی مفسر و مترجم و کامپایلر هست نمیشه. برای همین توی این آزمایشمون از زبان `C++` استفاده میکنیم.


کد زیر رو در نظر بگیرید:

```cpp
#include <iostream>
#include <sys/resource.h>
#include <chrono>

using namespace std;

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes
    
    // Code ----------------------------------------------------------
    char* arr = new char[1073741824];
    for(int i = 0; i < 1073741824 ; i++)
	    arr[i] = 'A';
    
    // ---------------------------------------------------------------
    
    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration<double, milli> execution_time_2 = end_2 - start_2;

    // Printing result
    cout << "Execution Time (Based on ctime): " << execution_time_1 * 1000.0 << " ms" << endl;
    cout << "Execution Time (Based on chrono): " << execution_time_2.count() << " ms" << endl;
    cout << "Memory Usage: " << memory_usage_end - memory_usage_start << " KB" << endl;

    return 0;
}
```

[فایل کد](./Files/RAM_write_test.cpp)

این قطعه کد زمان اجرا و میزان رم مصرفی مربوط به یک قطعه کد خاص رو اندازه‌گیری میکنه، اون قطعه کد خاص، سگمنت زیر هست که به اندازه دقیقاً 1 گیگابایت (1073741824 بایت) فضای رم رو تخصیص میده به یک آرایه از نوع کرکتر، اگه بخوام به زبان ساده بگم این قطعه کد که میبینید، دقیقاً 1 گیگابایت اطلاعات رو روی رم ذخیره میکنه:

```cpp
char* arr = new char[1073741824];
for(int i = 0; i < 1073741824 ; i++)
    arr[i] = 'A';
```

با اجرای این کد، میتونیم با یه تقریب خوبی بسنجیم که ذخیره کردن 1 گیگابایت از اطلاعات روی مموری بصورت دسترسی تصادفی (Random Access) چه مقدار زمانی طول میکشه و اینکه چقدر از مموری (RAM) استفاده میشه (منطقاً دقیقاً باید 1 گیگابایت استفاده بشه). این کد کزمان اجرای اون قطعه سگمنت مذکور رو یک بار با اساتفاده از کلاکها توی کتابخونه ctime میسنجه و بار دیگر با استفاده از کتابخونه chrono. بدین ترتیب ما میتونیم بگیرم زمان خروجی ما نسبتا دقیق هست، یادتون باشه که اینکلود کردن iostream توی این کامپایلر من خودش کتابخونه ctime رو هم به کد اضافه میکنه، اگه توی کامپایلر شما این قضه کار نکرد، حتما کتابخونه رو دستی اینکلود کنین:

`#include <ctime>`

بیاین کد رو اجرا کنیم تا ببینیم پاسخ چیه، من روی یه ماشین لینوکس هستم، پس کد رو با `g++ RAM_test.cpp` کامپایل میکنم و با `./a.out` اجرا میکنم.


نکته: همیـــشه یادتون باشه که در اینجور آزمایشها و مقایسه ها، انجام آزمایش (اجرای کد) رو حداقل 3 بار در شرایط مختلف تکرار کنید و متوسط کلی رو بعنوان پاسخ در نظر بگیرید، در هر لحظه توی یک ماشین کامپیوتری هزارن پراسس دیگر وجود دارن که با ریسورسها در حال تعامل هستن، رفتار این پراسس ها ممکنه در زمانهای متفاوت، تأثیری روی نتیجه آزمایش شما هم بذاره.

اجرای کد:

```bash
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ g++ RAM_test.cpp
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out         
Execution Time (Based on ctime): 2473.45 ms
Execution Time (Based on chrono): 2473.63 ms
Memory Usage: 1046788 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2431.39 ms
Execution Time (Based on chrono): 2431.43 ms
Memory Usage: 1046736 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2479.17 ms
Execution Time (Based on chrono): 2479.23 ms
Memory Usage: 1046820 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2419.52 ms
Execution Time (Based on chrono): 2419.6 ms
Memory Usage: 1046648 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2488.15 ms
Execution Time (Based on chrono): 2488.17 ms
Memory Usage: 1046788 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2482.35 ms
Execution Time (Based on chrono): 2482.44 ms
Memory Usage: 1046800 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2420.21 ms
Execution Time (Based on chrono): 2420.24 ms
Memory Usage: 1046788 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2426.54 ms
Execution Time (Based on chrono): 2426.59 ms
Memory Usage: 1046768 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2459.44 ms
Execution Time (Based on chrono): 2459.55 ms
Memory Usage: 1046784 KB
                                                                                                                             
┌──(user㉿dhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
└─$ ./a.out
Execution Time (Based on ctime): 2474.08 ms
Execution Time (Based on chrono): 2474.21 ms
Memory Usage: 1046916 KB

```

من این کد رو توی 10 بازه زمانی مختلف که سیستم من هر بار درگیر محاسبات متفاوتی بود اجرا کردم و خروجی به شرح بالا بود، همونطور که میبینید زمان اجرا با یه تقریب خاصی در یک رنجه، اما هر بار تغییرات جزئی داره که این نتیجه کارکردهای پارلل سیستم عامل ما هست، بعداً راجع به محاسبات موازی سیستم عامل یه مقاله مینویسم، اما مساله جالب دیگه اینه که میزان مموری مصرفی هم توی هر بار اجرا متفاوت بوده و این کمی عجیب بنظر میرسه… اما میشه تخصصی بررسیش کرد و اون موقع میبینیم که کاملاً معقوله. بررسی تخصصیش از حوصله این مقاله خارجه اما، بطور خیلی خلاصه میتونیم بگیم که کارکرد کد به کارکرد کتابخونه‌ها و توابعی که از سیستم اینکلود کردیم وابسته هست، این توابعی که کال کردیم هر بار اون زیر باک سیستم عامل دیتاهای متفاوتی رو وارد رم میکنن، و همین باعث متفاوت شدن میزان دیتای نشسته روی رم میشه، اما در کل روی رنج 1 گیگابایتی هست که سگمنت مذکور ما مصرف میکنه.
حالا میتونیم یه تخمینی از متوسط زمان داشته باشیم: 

```md
(2473.45+2473.63+2431.39+2431.43+2479.17+2479.23+2419.52+2419.6+2488.15+2488.17+2482.35+2482.44+2420.21+2420.24+2426.54+2426.59+2459.44+2459.55+2474.08+2474.21) / 20 = 49109.39000000001 / 20 = 2455.4695

(1046788+1046736+1046820+1046648+1046788+1046800+1046788+1046768+1046784+1046916) / 10 = 10467836 / 10 = 1046783.6

Therefore:

* Average Execution Time    = 2455.4695 ms
* Average Memory Usage      = 1046783.6 KB

```

همین اوردر زمانی ذخیره سازی دیتا بصورت دسترسی تصادفی روی رم، سرعتی که لازم داریم برای مقایسه رو به ما میده، سرعتش در عمل برابری میکنه با خوندن چیزی از رم بصورت دسترسی تصادفی.

حالا بریم سراغ هارددیسک و ببینیم که خوندن/نوشتن یک گیگابایت از دیتا روی HDD چه مقدار زمان/ریسورس مصرف میکنه. البته در بحث این مقایسه دیگه ریسورسش مد نظر ما نیست، بلکه زمانش برای ما مهمه.

کد زیر رو در نظر بگیرید:


______________________________________

یکسری لینک پرسش و پاسخ مرتبط با این موضوع:


* _https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access_
* _https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk_
* _https://queue.acm.org/detail.cfm?id=1563874_



و تمام، هارددیسک بطور متوسط 100000 بار از رم کند تره:))


## کپی رایت

این یک مقاله آزاد و متن‌باز تحت مجوز GFDL1-3 می‌باشد، بنابراین اجازه کپی، توزیع و/یا تغییر این سند با شرایط مجوز GNU Free Documentation License داده شده است.

## منابع

+ https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm
+ https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041
+ Database System Concepts, 6th Edition
+ http://www.foundersatwork.com/steve-wozniak.html
+ https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90