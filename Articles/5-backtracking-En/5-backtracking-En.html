<!DOCTYPE HTML><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><title>Backtracking</title> <link href="https://tadavomnist.github.io/assets/css/highlightjs.default.min.css" rel="stylesheet"/><style type="text/css">*,pre code,table,table tr{padding:0}hr,html{overflow:hidden}*{box-sizing:border-box;outline:0;margin:0}body,html{position:relative;width:100vw;height:100vh}html{color-scheme:light}body{padding:10px 15px;overflow:hidden auto;overflow-wrap:break-word;word-wrap:break-word;font:16px/1.4 Helvetica,Arial,sans-serif;color:#333}body,html,table tr{background-color:#fff}.highlight pre,code,pre,tt{background-color:#f8f8f8;direction:ltr!important}table tr :is(th,td){border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{position:relative;box-sizing:content-box;font-weight:700;padding:15px 0;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;border:0;border-bottom:1px solid #ddd}a{color:#4183c4}a.absent{color:#c00}ol,ul{padding-left:15px;margin:0 7px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr :is(th,td) :first-child{margin-top:0}table tr :is(th,td) :last-child{margin-bottom:0}img{max-width:100%;pointer-events:none}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;overflow-wrap:break-word;border:1px solid #eaeaea;border-radius:3px}tt{white-space:nowrap}pre code{white-space:pre;border:none}.highlight pre,pre{border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;margin:.8em 0 1em;border-radius:3px;max-width:calc(100% - 2px)}#container{max-width:960px;margin: 0 auto;}.dark-mode{background-color:#000;color:#fff;}.dark-mode table tr{background-color:#000}.dark-mode table tr:nth-child(2n){background-color:#333}.dark-mode code{background-color:#212121;color:rgb(0,183,255);}.dark-mode pre{background-color:#433f3f !important;}*,*:before,*:after{box-sizing:border-box;}.toggle{cursor:pointer;display:inline-block;}.toggle-switch{display:inline-block;background:#ccc;border-radius:16px;width:58px;height:32px;position:relative;vertical-align:middle;transition:background 0.25s;}.toggle-switch:before,.toggle-switch:after{content:"";}.toggle-switch:before{display:block;background:linear-gradient(to bottom,#fff 0%,#eee 100%);border-radius:50%;box-shadow:0 0 0 1px rgba(0,0,0,0.25);width:24px;height:24px;position:absolute;top:4px;left:4px;transition:left 0.25s;}.toggle:hover .toggle-switch:before{background:linear-gradient(to bottom,#fff 0%,#fff 100%);box-shadow:0 0 0 1px rgba(0,0,0,0.5);}.toggle-checkbox:checked + .toggle-switch{background:#3e96df;}.toggle-checkbox:checked + .toggle-switch:before{left:30px;}.toggle-checkbox{position:absolute;visibility:hidden;}.toggle-label{margin-left:5px;position:relative;top:2px;}</style></head><body><div id="container"><div id="container"><label class="toggle"><input class="toggle-checkbox" type="checkbox" id="dark-mode-toggle"><div class="toggle-switch"></div><span class="toggle-label">Dark mode</span></label><h1>Backtracking Algorithm in Artificial Intelligence</h1><br />
<h2>Abstract</h2><br />
<p>In this article, we discuss in detail a fundamental algorithm in artificial intelligence called backtracking and answer the following questions:</p>
<ul>
<li>What is the n-rooks (rook polynomial) problem?</li>
<li>What is the n-queens problem?</li>
<li>What is the backtracking algorithm?</li>
<li>How can we solve the n-rooks problem using the backtracking approach?</li>
<li>How can we solve the n-queens problem using the backtracking approach?</li>
<li>How can we print an array as a tree structure in PHP?</li>
</ul><br />
<h2>The n-Queens and n-Rooks Problem</h2><br />
<p>One of the fundamental goals in artificial intelligence is to model our problems with mathematics and solve them using appropriate algorithms. Backtracking refers to a particular type of algorithm where we can find solutions to a mathematical problem by exploring and backtracking (undoing) steps. To explain this concept, I will use two well-known examples.</p><br />
<p>I propose two questions:</p><br />
<p><strong>Question 1:</strong><br />
Difficulty Level: Medium to Hard</p>
<ul>
<li>We want to place n rooks on an n×n chessboard in such a way that they do not attack each other, meaning none of them can capture another one. For each input n, print all the possible answers as a matrix...</li>
</ul><br />
<p><strong>For n = 1: Only one answer should be printed:</strong></p>
<pre><code>1</code></pre><br />
<p><strong>For n = 2: Two answers should be printed:</strong></p>
<pre><code>10
01

01
10</code></pre><br />
<p><strong>For n = 3: Six answers should be printed:</strong></p>
<pre><code>100
010
001

001
010
100

010
001
100

001
100
010

010
100
001

100
001
010</code></pre><br />
<p>Note 1: We represent our chessboard as binary square matrices where 1s represent the rooks and 0s represent empty cells.</p><br />
<p>Note 2: Keep in mind that a rook can only move in its row, column, and attack diagonals.</p><br />
<hr /><br />
<p>And the second question, which in truth is a more complex version of the first question:</p><br />
<p><strong>Question 2:</strong><br />
Difficulty Level: Medium to Hard</p><br />
<p>I want to extend the example of the n-rooks problem to a better and more comprehensive puzzle.</p>
<ul>
<li>We want to place n queens on an n×n chessboard in such a way that they do not attack each other, meaning none of them can capture another one. For each input n, print all the possible answers as a matrix...</li>
</ul><br />
<p><strong>For n = 1: Only one answer should be printed:</strong></p>
<pre><code>1</code></pre><br />
<p><strong>For n = 2: No answers should be printed!</strong></p><br />
<p>The problem does not have a solution for n = 2.</p><br />
<p><strong>For n = 3: No answers should be printed!!</strong></p><br />
<p>The problem does not have a solution for n = 3.</p><br />
<p><strong>For n = 4: Two answers should be printed:</strong></p>
<pre><code>0010
1000
0001
0100

0100
0001
1000
0010</code></pre><br />
<p><strong>For n = 5: Ten answers should be printed:</strong></p>
<pre><code>00010
01000
00001
00100
10000

01000
00010
10000
00100
00001

10000
00100
00001
01000
00010

10000
00010
01000
00001
00100

00001
00100
10000
00010
01000

00100
10000
00010
01000
00001

00100
00001
01000
00010
10000

00001
01000
00010
10000
00100

01000
00001
00100
10000
00010

00010
10000
00100
00001
01000</code></pre><br />
<p><strong>And here are the visual representations of these ten answers (n = 5) for better comprehending:</strong></p><br />
<p><img src="Files/5queens.jpg" alt="5 Queens" /></p><br />
<p>(Note: I don't remember the source of the image.)</p><br />
<p>Note 1: We represent our chessboard as binary square matrices where 1s represent the queens and 0s represent empty cells.</p><br />
<p>Note 2: Keep in mind that a queen can move in its row, column, and diagonals to attack.</p><br />
<h2>What is the Backtracking Algorithm?</h2><br />
<p>Well, now it's time to answer these questions that we've presented. But before that, I'll explain a few necessary concepts:</p><br />
<p>The n-queens problem is one of the challenging problems for mathematicians and has led them to seek optimal solutions. However, since the problem may be confusing for beginners, I decided to start with a simpler version, which is the n-rooks problem. It serves as a simplified version of the n-queens problem. Remember, programmers and algorithm designers primarily focus on the n-queens problem.</p><br />
<p>Scientists and academic professors commonly discuss the n-queens problem along with other simple problems to establish a connection between algorithm science and artificial intelligence, aiming to explain artificial intelligence algorithms through them.</p><br />
<p>There are infinite approaches to solving the n-queens problem as well as the n-rooks problem. These include solutions derived from algorithm science and artificial intelligence, mathematical and matrix-based solutions, and the solutions that have not been discovered yet...</p>
<ul>
<li>Backtracking Algorithm<ul>
<li>Monte Carlo Algorithm</li>
</ul>
</li>
<li>Constraint Satisfaction Problem (CSP) Algorithm</li>
<li>Heuristic Algorithm</li>
<li>Hill Climbing Algorithm</li>
<li>Local Search Algorithm</li>
<li>Genetic Algorithm</li>
<li>And other algorithms that are not mentioned...</li>
</ul><br />
<p>My goal here is to solve this problem using the Backtracking algorithm.</p><br />
<p>There are two reasons why I chose this approach (backtracking):</p><br />
<ol><br />
<li>This approach utilizes the decision tree structure. It uses modeling through tree structures, allowing me to introduce trees to some extent.</li><br />
<li>This approach is based on the "trial and error" method, which is the first solution that comes to mind for all humans.</li><br />
</ol><br />
<hr /><br />
<h3>Trees: An Indispensable Concept in Computer Science</h3><br />
<p>Before talking about backtracking algorithm, I want to highlight the importance of trees:</p><br />
<p>Trees are indispensable elements in computer science. The concept of trees is extremely important – anyone entering the field of computer science eventually needs to learn about them.</p><br />
<p>Here are some notable uses of trees in computer science:</p>
<ul>
<li>Many hard disk formats utilize trees for partition configuration and file organization.<ul>
<li>For example, the ext file format employs a structure called an <code>inode</code> which essentially represents a tree structure.</li>
</ul>
</li>
<li>File storage and directory configuration worldwide are modeled using trees. The main directory (root directory) serves as the parent directory, with others becoming its children. Each directory can have its own children, and so on. If you're using a Unix-like system, you can visualize the tree structure by using the <code>tree</code> command.<ul>
<li>Directory configurations in Linux or any other operating system are universally based on trees. You might be familiar with the term "parent directory", which refers to the node in a tree.</li>
</ul>
</li>
<li>The fastest databases in the world, and I emphasize the word "fastest," are built on tree structures. Here are a few examples:<ul>
<li>The MySQL database uses the B-tree.</li>
<li>MongoDB uses the B+ tree.</li>
<li>The PostgreSQL database uses B+ trees for efficient data indexing and storage.</li>
<li>Storing data in a self-balancing tree like the B+ tree significantly enhances the speed of access, search, read, write (inculding insertion and deletion) operations. Som basically the speed of CRUD operations is powered by tree structures. Using mathematical formulas, it can be proven that even in the worst-case scenario, we can perform the access I/O with logarithmic complexity. For instance, given 1 billion stored data entries, we can locate specific data with fewer than 20 comparisons and seek operations! (Ever wondered how Instagram manages to switch between billions of posts and users?!)</li>
</ul>
</li>
<li>Social media platforms and social networks, such as Telegram, Instagram, and Facebook, are established on graph structures (a more general form of a tree).</li>
<li>Search engines employ trees to store indexed documents.</li>
<li>The legendary UNIX operating system is built upon a tree structure.<ul>
<li>Following the previous point, the entire Linux system is entirety tree-based.</li>
<li>User access management in Linux is modeled with trees (you've heard of root access, right? Well, root means the tree root node).</li>
<li>The handling of system processes in Unix-based systems like Linux is also based on a tree structure. Don't believe it? Try the <code>pstree</code> command to visualize the process tree of your operating system.</li>
<li>Managing threads in operating systems is also accomplished using trees.</li>
<li>Approximately 90% of the world's operating systems are Linux-based, thus making use of tree structures.</li>
<li>Other UNIX-based systems also rely on tree-based architectures.</li>
</ul>
</li>
<li>Network elements are modeled with graphs.</li>
<li>Trees are employed in a significant proportion of dynamic arrays.</li>
<li>HTML is structured based on a tree hierarchy.</li>
<li>HTML/XML parsing relies on tree structures.</li>
<li>There's a concept in web science called the Document Object Model (DOM), which models web pages as trees.</li>
<li>Trees play a fundamental role in the design of compilers, interpreters, and programming languages.</li>
<li>Trees have a wide-ranging role in artificial intelligence, which we'll talk a bit more about it.</li>
<li>Many network routing algorithms operate on trees.</li>
<li>The hierarchical structure of the Domain Name System (DNS) is based on a tree. (have you heard of root DNS servers?).</li>
<li>Version control systems (VCS) like Git operate on a tree structure to effectively manage their branches.</li>
<li>...</li>
</ul><br />
<p>Well, I won't say anything more about the advantages of trees because if I continue, we won't reach the end of our article...<br />
Also, I mentioned something called the B+ tree, which may be the subject of a separate article in the future.</p><br />
<p>So, trees are indeed something important...</p><br />
<hr /><br />
<p>Alright, alright... Let's go solve the n-rooks problem:</p><br />
<p>The backtracking algorithm says:</p><br />
<p><strong>"Hello mate:3<br />
Do you want to model a difficult math problem with me? Do you want to transform your solution into a standardized one? Model the problem and its solution using a tree."</strong></p><br />
<p>So what does this mean?</p><br />
<p>Imagine you ask someone who is unfamiliar with mathematics and algorithms to arrange 8 rooks on a chessboard in a way that they don't attack each other:<br />
This person starts placing the first rook, then the second one and continues... then when they reach the 5th rook, they realize that the position they chose allows the 3rd rook to be attacked... There's no cell left to place the rook safely... <br />
So they <strong>go back</strong> and change the positions of the 4th and 3rd rooks. They keep doing this until they finally find one of the possible solutions and present it to you.<br />
Unintentionally, this person used the backtracking algorithm.</p><br />
<p><strong>Note</strong>: Our goal in this article is not to find the first possible solution. The goal is to find all possible solutions.</p><br />
<p>In the backtracking algorithm, we create a "decision tree" and model our problem on that tree:<br />
Before I show you the tree for a few initial scenarios, let me provide a brief explanation of the tree's structure using some illustrations. This way, you won't get confused when I mention terms like - node - root - parent - child - leaf - depth - sibling... However, it's important to note that describing trees comprehensively would require an extensive explanation, perhaps even exceeding a hundred books!</p><br />
<h3>What is a tree? (Simple Explanation)</h3></div><script src="https://tadavomnist.github.io/assets/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://tadavomnist.github.io/assets/js/MathJax.js" type="text/javascript"></script><script type="text/javascript">MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});</script><script>document.addEventListener("DOMContentLoaded", ev => document.body.querySelectorAll("#container > *").forEach(elm => elm.setAttribute("dir", "auto")));</script><script>const toggleButton = document.getElementById("dark-mode-toggle");const container = document.getElementById("container");const body = document.body;if (toggleButton.checked) {enableDarkMode();}toggleButton.addEventListener("click", () => {if (!toggleButton.checked) {disableDarkMode();} else {enableDarkMode();}});function enableDarkMode() {body.classList.add("dark-mode");localStorage.setItem("darkModeEnabled", true);}function disableDarkMode() {body.classList.remove("dark-mode");localStorage.removeItem("darkModeEnabled");}</script></body></html>