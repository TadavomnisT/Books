<!DOCTYPE HTML><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><title>Backtracking</title> <link href="https://tadavomnist.github.io/assets/css/highlightjs.default.min.css" rel="stylesheet"/><style type="text/css">*,pre code,table,table tr{padding:0}hr,html{overflow:hidden}*{box-sizing:border-box;outline:0;margin:0}body,html{position:relative;width:100vw;height:100vh}html{color-scheme:light}body{padding:10px 15px;overflow:hidden auto;overflow-wrap:break-word;word-wrap:break-word;font:16px/1.4 Helvetica,Arial,sans-serif;color:#333}body,html,table tr{background-color:#fff}.highlight pre,code,pre,tt{background-color:#f8f8f8;direction:ltr!important}table tr :is(th,td){border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{position:relative;box-sizing:content-box;font-weight:700;padding:15px 0;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;border:0;border-bottom:1px solid #ddd}a{color:#4183c4}a.absent{color:#c00}ol,ul{padding-left:15px;margin:0 7px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr :is(th,td) :first-child{margin-top:0}table tr :is(th,td) :last-child{margin-bottom:0}img{max-width:100%;pointer-events:none}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;overflow-wrap:break-word;border:1px solid #eaeaea;border-radius:3px}tt{white-space:nowrap}pre code{white-space:pre;border:none}.highlight pre,pre{border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;margin:.8em 0 1em;border-radius:3px;max-width:calc(100% - 2px)}#container{max-width:960px;margin: 0 auto;}.dark-mode{background-color:#000;color:#fff;}.dark-mode table tr{background-color:#000}.dark-mode table tr:nth-child(2n){background-color:#333}.dark-mode code{background-color:#212121;color:rgb(0,183,255);}.dark-mode pre{background-color:#433f3f !important;}*,*:before,*:after{box-sizing:border-box;}.toggle{cursor:pointer;display:inline-block;}.toggle-switch{display:inline-block;background:#ccc;border-radius:16px;width:58px;height:32px;position:relative;vertical-align:middle;transition:background 0.25s;}.toggle-switch:before,.toggle-switch:after{content:"";}.toggle-switch:before{display:block;background:linear-gradient(to bottom,#fff 0%,#eee 100%);border-radius:50%;box-shadow:0 0 0 1px rgba(0,0,0,0.25);width:24px;height:24px;position:absolute;top:4px;left:4px;transition:left 0.25s;}.toggle:hover .toggle-switch:before{background:linear-gradient(to bottom,#fff 0%,#fff 100%);box-shadow:0 0 0 1px rgba(0,0,0,0.5);}.toggle-checkbox:checked + .toggle-switch{background:#3e96df;}.toggle-checkbox:checked + .toggle-switch:before{left:30px;}.toggle-checkbox{position:absolute;visibility:hidden;}.toggle-label{margin-left:5px;position:relative;top:2px;}</style></head><body><div id="container"><div id="container"><label class="toggle"><input class="toggle-checkbox" type="checkbox" id="dark-mode-toggle"><div class="toggle-switch"></div><span class="toggle-label">Dark mode</span></label><h1>Backtracking Algorithm in Artificial Intelligence</h1><br />
<h2>Abstract</h2><br />
<p>In this article, we discuss in detail a fundamental algorithm in artificial intelligence called backtracking and answer the following questions:</p>
<ul>
<li>What is the n-rooks (rook polynomial) problem?</li>
<li>What is the n-queens problem?</li>
<li>What is the backtracking algorithm?</li>
<li>How can we solve the n-rooks problem using the backtracking approach?</li>
<li>How can we solve the n-queens problem using the backtracking approach?</li>
<li>How can we print an array as a tree structure in PHP?</li>
</ul><br />
<h2>The n-Queens and n-Rooks Problem</h2><br />
<p>One of the fundamental goals in artificial intelligence is to model our problems with mathematics and solve them using appropriate algorithms. Backtracking refers to a particular type of algorithm where we can find solutions to a mathematical problem by exploring and backtracking (undoing) steps. To explain this concept, I will use two well-known examples.</p><br />
<p>I propose two questions:</p><br />
<p><strong>Question 1:</strong><br />
Difficulty Level: Medium to Hard</p>
<ul>
<li>We want to place n rooks on an n×n chessboard in such a way that they do not attack each other, meaning none of them can capture another one. For each input n, print all the possible answers as a matrix...</li>
</ul><br />
<p><strong>For n = 1: Only one answer should be printed:</strong></p>
<pre><code>1</code></pre><br />
<p><strong>For n = 2: Two answers should be printed:</strong></p>
<pre><code>10
01

01
10</code></pre><br />
<p><strong>For n = 3: Six answers should be printed:</strong></p>
<pre><code>100
010
001

001
010
100

010
001
100

001
100
010

010
100
001

100
001
010</code></pre><br />
<p>Note 1: We represent our chessboard as binary square matrices where 1s represent the rooks and 0s represent empty cells.</p><br />
<p>Note 2: Keep in mind that a rook can only move in its row, column, and attack diagonals.</p><br />
<hr /><br />
<p>And the second question, which in truth is a more complex version of the first question:</p><br />
<p><strong>Question 2:</strong><br />
Difficulty Level: Medium to Hard</p><br />
<p>I want to extend the example of the n-rooks problem to a better and more comprehensive puzzle.</p>
<ul>
<li>We want to place n queens on an n×n chessboard in such a way that they do not attack each other, meaning none of them can capture another one. For each input n, print all the possible answers as a matrix...</li>
</ul><br />
<p><strong>For n = 1: Only one answer should be printed:</strong></p>
<pre><code>1</code></pre><br />
<p><strong>For n = 2: No answers should be printed!</strong></p><br />
<p>The problem does not have a solution for n = 2.</p><br />
<p><strong>For n = 3: No answers should be printed!!</strong></p><br />
<p>The problem does not have a solution for n = 3.</p><br />
<p><strong>For n = 4: Two answers should be printed:</strong></p>
<pre><code>0010
1000
0001
0100

0100
0001
1000
0010</code></pre><br />
<p><strong>For n = 5: Ten answers should be printed:</strong></p>
<pre><code>00010
01000
00001
00100
10000

01000
00010
10000
00100
00001

10000
00100
00001
01000
00010

10000
00010
01000
00001
00100

00001
00100
10000
00010
01000

00100
10000
00010
01000
00001

00100
00001
01000
00010
10000

00001
01000
00010
10000
00100

01000
00001
00100
10000
00010

00010
10000
00100
00001
01000</code></pre><br />
<p><strong>And here are the visual representations of these ten answers (n = 5) for better comprehending:</strong></p><br />
<p><img src="Files/5queens.jpg" alt="5 Queens" /></p><br />
<p>(Note: I don't remember the source of the image.)</p><br />
<p>Note 1: We represent our chessboard as binary square matrices where 1s represent the queens and 0s represent empty cells.</p><br />
<p>Note 2: Keep in mind that a queen can move in its row, column, and diagonals to attack.</p><br />
<h2>What is the Backtracking Algorithm?</h2><br />
<p>Well, now it's time to answer these questions that we've presented. But before that, I'll explain a few necessary concepts:</p><br />
<p>The n-queens problem is one of the challenging problems for mathematicians and has led them to seek optimal solutions. However, since the problem may be confusing for beginners, I decided to start with a simpler version, which is the n-rooks problem. It serves as a simplified version of the n-queens problem. Remember, programmers and algorithm designers primarily focus on the n-queens problem.</p><br />
<p>Scientists and academic professors commonly discuss the n-queens problem along with other simple problems to establish a connection between algorithm science and artificial intelligence, aiming to explain artificial intelligence algorithms through them.</p><br />
<p>There are infinite approaches to solving the n-queens problem as well as the n-rooks problem. These include solutions derived from algorithm science and artificial intelligence, mathematical and matrix-based solutions, and the solutions that have not been discovered yet...</p>
<ul>
<li>Backtracking Algorithm<ul>
<li>Monte Carlo Algorithm</li>
</ul>
</li>
<li>Constraint Satisfaction Problem (CSP) Algorithm</li>
<li>Heuristic Algorithm</li>
<li>Hill Climbing Algorithm</li>
<li>Local Search Algorithm</li>
<li>Genetic Algorithm</li>
<li>And other algorithms that are not mentioned...</li>
</ul><br />
<p>My goal here is to solve this problem using the Backtracking algorithm.</p><br />
<p>There are two reasons why I chose this approach (backtracking):</p><br />
<ol><br />
<li>This approach utilizes the decision tree structure. It uses modeling through tree structures, allowing me to introduce trees to some extent.</li><br />
<li>This approach is based on the "trial and error" method, which is the first solution that comes to mind for all humans.</li><br />
</ol><br />
<hr /><br />
<h3>Trees: An Indispensable Concept in Computer Science</h3><br />
<p>Before talking about backtracking algorithm, I want to highlight the importance of trees:</p><br />
<p>Trees are indispensable elements in computer science. The concept of trees is extremely important – anyone entering the field of computer science eventually needs to learn about them.</p><br />
<p>Here are some notable uses of trees in computer science:</p>
<ul>
<li>Many hard disk formats utilize trees for partition configuration and file organization.<ul>
<li>For example, the ext file format employs a structure called an <code>inode</code> which essentially represents a tree structure.</li>
</ul>
</li>
<li>File storage and directory configuration worldwide are modeled using trees. The main directory (root directory) serves as the parent directory, with others becoming its children. Each directory can have its own children, and so on. If you're using a Unix-like system, you can visualize the tree structure by using the <code>tree</code> command.<ul>
<li>Directory configurations in Linux or any other operating system are universally based on trees. You might be familiar with the term "parent directory", which refers to the node in a tree.</li>
</ul>
</li>
<li>The fastest databases in the world, and I emphasize the word "fastest," are built on tree structures. Here are a few examples:<ul>
<li>The MySQL database uses the B-tree.</li>
<li>MongoDB uses the B+ tree.</li>
<li>The PostgreSQL database uses B+ trees for efficient data indexing and storage.</li>
<li>Storing data in a self-balancing tree like the B+ tree significantly enhances the speed of access, search, read, write (inculding insertion and deletion) operations. Som basically the speed of CRUD operations is powered by tree structures. Using mathematical formulas, it can be proven that even in the worst-case scenario, we can perform the access I/O with logarithmic complexity. For instance, given 1 billion stored data entries, we can locate specific data with fewer than 20 comparisons and seek operations! (Ever wondered how Instagram manages to switch between billions of posts and users?!)</li>
</ul>
</li>
<li>Social media platforms and social networks, such as Telegram, Instagram, and Facebook, are established on graph structures (a more general form of a tree).</li>
<li>Search engines employ trees to store indexed documents.</li>
<li>The legendary UNIX operating system is built upon a tree structure.<ul>
<li>Following the previous point, the entire Linux system is entirety tree-based.</li>
<li>User access management in Linux is modeled with trees (you've heard of root access, right? Well, root means the tree root node).</li>
<li>The handling of system processes in Unix-based systems like Linux is also based on a tree structure. Don't believe it? Try the <code>pstree</code> command to visualize the process tree of your operating system.</li>
<li>Managing threads in operating systems is also accomplished using trees.</li>
<li>Approximately 90% of the world's operating systems are Linux-based, thus making use of tree structures.</li>
<li>Other UNIX-based systems also rely on tree-based architectures.</li>
</ul>
</li>
<li>Network elements are modeled with graphs.</li>
<li>Trees are employed in a significant proportion of dynamic arrays.</li>
<li>HTML is structured based on a tree hierarchy.</li>
<li>HTML/XML parsing relies on tree structures.</li>
<li>There's a concept in web science called the Document Object Model (DOM), which models web pages as trees.</li>
<li>Trees play a fundamental role in the design of compilers, interpreters, and programming languages.</li>
<li>Trees have a wide-ranging role in artificial intelligence, which we'll talk a bit more about it.</li>
<li>Many network routing algorithms operate on trees.</li>
<li>The hierarchical structure of the Domain Name System (DNS) is based on a tree. (have you heard of root DNS servers?).</li>
<li>Version control systems (VCS) like Git operate on a tree structure to effectively manage their branches.</li>
<li>...</li>
</ul><br />
<p>Well, I won't say anything more about the advantages of trees because if I continue, we won't reach the end of our article...<br />
Also, I mentioned something called the B+ tree, which may be the subject of a separate article in the future.</p><br />
<p>So, trees are indeed something important...</p><br />
<hr /><br />
<p>Alright, alright... Let's solve the n-rooks problem:</p><br />
<p>The backtracking algorithm says:</p><br />
<p><strong>"Hello mate:3<br />
Do you want to model a difficult math problem with me? Do you want to transform your solution into a standardized one? Model the problem and its solution using a tree."</strong></p><br />
<p>So what does this mean?</p><br />
<p>Imagine you ask someone who is unfamiliar with mathematics and algorithms to arrange 8 rooks on a chessboard in a way that they don't attack each other:<br />
This person starts placing the first rook, then the second one and continues... then when they reach the 5th rook, they realize that the position they chose allows the 3rd rook to be attacked... There's no cell left to place the rook safely... <br />
So they <strong>go back</strong> - retrace the steps - and change the positions of the 4th and 3rd rooks. They keep doing this until they finally find one of the possible solutions and present it to you.<br />
Unintentionally, this person used the backtracking algorithm.</p><br />
<p><strong>Note</strong>: Our goal in this article is not to find the first possible solution. The goal is to find all possible solutions.</p><br />
<p>In the backtracking algorithm, we create a "decision tree" and model our problem on that tree:<br />
Before I show you the tree for a few initial scenarios, let me provide a brief explanation of the tree's structure using some illustrations. This way, you won't get confused when I mention terms like - node - root - parent - child - leaf - depth - sibling... However, it's important to note that describing trees comprehensively would require an extensive explanation, perhaps even exceeding a hundred books!</p><br />
<h3>What is a tree? (Simple Explanation)</h3><br />
<p><img src="Files/tree_structure.png" alt="Tree structure" /></p><br />
<p>Explanation:</p><br />
<p><strong>Definition of a Tree</strong>: A tree is a graph that does not have any cycles.</p>
<ul>
<li>Similar to trees in a garden, every tree must have exactly one root - we don't have a tree without a root. Even a tree with a single node becomes its own root (though it is also considered a leaf - explained later).</li>
<li><strong>Edge</strong>: Read about edge definitions in graphs; they are more relevant there. In a tree, edges connect the nodes together. Nothing major.</li>
<li><strong>Node/Vertex</strong>: We call the circles where we write values as nodes or vertices^_^ Read about the special definitions of graphs to learn more about them.</li>
<li><strong>Leaf</strong>: A node that does not have any children is called a leaf.</li>
<li><strong>Parent</strong>: A node that has children is the parent for its children.</li>
<li><strong>Child</strong>: A node that directly originates from another node is called a child of that node.</li>
<li><strong>Sibling</strong>: Nodes that share the same parent are called siblings.</li>
<li><strong>Depth</strong>: Depth... I think it refers to the number of edges traversed from the root to reach that particular node. But I've also shown it in the diagram... You'll easily understand what depth means.</li>
</ul><br />
<p><strong>Important Note</strong>: I won't provide further explanations about trees. To learn about trees, it is necessary to study graphs. So, read graphs from discrete mathematics.</p><br />
<hr /><br />
<h3>Solving n-rooks problem and n-queens problem using the backtracking approach</h3><br />
<p>Okay, let's model the problem using a tree (Decision-tree) and the backtracking approach:</p><br />
<p>For n = 1, what do we have?<br />
We have a chessboard with only one square:</p><br />
<p><img src="Files/1chess.png" alt="1 chess" /></p>
<pre><code>1</code></pre><br />
<p>So constructing its tree is not difficult:<br />
We place a rook on the chessboard at the cell in [0,0], then we check if the placement okay or not. If it is okay, we are done. If not, we backtrack and try again.<br />
It's ok so we keep up^_^</p><br />
<p><img src="Files/1tree.png" alt="1 tree" /></p>
<pre><code>"root"
State_0
    └── [0,0]</code></pre><br />
<p>Look at the root, which state did I choose? State 0 - which means S0, which means the starting point, which means when we haven't placed anything yet. You can write it in another way if you want.</p><br />
<hr /><br />
<p>For n = 2, it becomes a bit more interesting.<br />
Look chessboard and decision-tree my pretties:</p><br />
<p><img src="Files/2chess.png" alt="2 chess" /></p>
<pre><code>00
00</code></pre><br />
<p><img src="Files/2tree.png" alt="2 tree" /></p>
<pre><code>"root"
State_0</code></pre><br />
<p><strong>Very important note</strong>: In the question I mentioned, there is an implicit point that there is no difference between different rooks or queens. The first rook is considered the same as the second rook, meaning we don't distinguish between them. In the code I provided, you can specify whether there should be a distinction between the pieces or not. Ahm let's explain a bit more: The assumption we made is that, considering these:</p><br />
<p><img src="Files/2_1.png" alt="2 queens alternative" /></p>
<pre><code>10
02</code></pre><br />
<p><img src="Files/2_2.png" alt="2 queens alternative" /></p>
<pre><code>20
01</code></pre><br />
<p>In the two cases above, where in the picture, the blue rook [1] is the first one we placed and the red rook [2] is the second one, in the question, we assumed that there is no difference between them and both represent the same <strong>single answer</strong> below:</p><br />
<p><img src="Files/2_3.png" alt="2 queens alternative" /></p>
<pre><code>10
01</code></pre><br />
<p>But we should consider a more general case where we differentiate between the rooks. Because the solutions in this case are more complete and include the solutions in the "indifferent" part as well.</p><br />
<p>Now let's solve it using backtracking:<br />
We place the first rook in cell [0,0]:</p><br />
<p><img src="Files/2_chess1.png" alt="2 chees1" /></p>
<pre><code>10
00</code></pre><br />
<p>The decision tree so far looks like this:</p><br />
<p><img src="Files/2_tree1.png" alt="2 tree1" /></p>
<pre><code>root
└── [0,0]</code></pre><br />
<p>Now it's time to place the second rook. According to the order, we placed the first one in [0,0], so we place the second one in [0,1]. So we have:</p><br />
<p><img src="Files/2_chess2.png" alt="2 chess2" /></p>
<pre><code>11
00</code></pre><br />
<p>The decision tree becomes like this:</p><br />
<p><img src="Files/2_tree2.png" alt="2 tree2" /></p>
<pre><code>root
└── [0,0]
    └── [0,1]</code></pre><br />
<p>And now... we check if it is okay. We see that it is not okay! The rooks are attacking each other. So we backtrack and take a step back (we call it backtracking). We remove the piece we placed and go back to its parent node in the tree and place the next child node - it was not our solution!</p><br />
<p><img src="Files/2_chess1.png" alt="2 chess1" /></p>
<pre><code>10
00</code></pre><br />
<p>And the decision tree becomes this again:</p><br />
<p><img src="Files/2_tree1.png" alt="2 tree1" /></p>
<pre><code>root
└── [0,0]</code></pre><br />
<p>Just because I deleted the node in the figure, it doesn't mean I should delete it in the code too. It depends on how the programmer implements it; they might say that I want to keep the visited nodes if they don't have a solution so that I know I visited them later... or they might implement a whole different approach...<br />
Anyway, I'll show you the complete tree later; Right now le'ts focus on the algorithm.</p><br />
<p>Alright, according to the order, we place the next rook at position [1,0], so we have:</p><br />
<p><img src="Files/2_chess3.png" alt="2 chess3" /></p>
<pre><code>10
10</code></pre><br />
<p>Decision tree:</p><br />
<p><img src="Files/2_tree3.png" alt="2 chess3" /></p>
<pre><code>root
└── [0,0]
    └── [1,0]</code></pre><br />
<p>But... they can attack each other :(<br />
Backtracking again...</p><br />
<p><img src="Files/2_chess1.png" alt="2 chess1" /></p>
<pre><code>10
00</code></pre><br />
<p>And it the tree again:</p><br />
<p><img src="Files/2_tree1.png" alt="2 tree1" /></p>
<pre><code>root
└── [0,0]</code></pre><br />
<p>Now it's time to place the rook at position [1,1]:</p><br />
<p><img src="Files/2_chess4.png" alt="2 chess4" /></p>
<pre><code>10
01✅</code></pre><br />
<p>And here is the decision tree:</p><br />
<p><img src="Files/2_tree4.png" alt="2 tree4" /></p>
<pre><code>root
└── [0,0]
    └── [1,1]✅</code></pre><br />
<p>We check, this is one of the possible solutions, so wooohoooo :)<br />
We can print it or save it, whatever we want to do, let's move on to the next step.</p><br />
<p>We backtrack until the board is empty:</p><br />
<p><img src="Files/2chess.png" alt="2 rooks placement" /></p>
<pre><code>00
00</code></pre><br />
<p>And the tree:</p><br />
<p><img src="Files/2tree.png" alt="2 tree" /></p>
<pre><code>root</code></pre><br />
<hr /><br />
<p><strong>I'll say it again!</strong> It's not like we delete the nodes! I do it this way because I'm explaining it hierarchically, so it doesn't get messy and confusing.</p>
<ul>
<li>Let's move on.</li>
</ul><br />
<p>We placed the first rook in the previous step at [0,0], this time we place it at [0,1] according to the order:</p><br />
<p><img src="Files/2_chess6.png" alt="2 rooks placement" /></p>
<pre><code>01
00</code></pre><br />
<p>And the tree:</p><br />
<p><img src="Files/2_tree5.png" alt="2 rooks placement" /></p>
<pre><code>root
└── [0,1]</code></pre><br />
<p>I'll quickly go through the steps until the end:</p><br />
<p><img src="Files/2_4.png" alt="2 rooks placement" /></p>
<pre><code>Board:
11
00

Tree:
root
└── [0,1]
    └── [0,0]</code></pre><br />
<hr /><br />
<p><img src="Files/2_5.png" alt="2 rooks placement" /></p>
<pre><code>Board:
01
10✅

Tree:
root
└── [0,1]
    └── [1,0]✅</code></pre><br />
<hr /><br />
<p><img src="Files/2_6.png" alt="2 rooks placement" /></p>
<pre><code>Board:
01
01

Tree:
root
└── [0,1]
    └── [1,1]</code></pre><br />
<hr /><br />
<p><img src="Files/2_7.png" alt="2 rooks placement" /></p>
<pre><code>Board:
00
00

Tree:
root</code></pre><br />
<hr /><br />
<p><img src="Files/2_8.png" alt="2 rooks placement" /></p>
<pre><code>Board:
00
10

Tree:
root
└── [1,0]</code></pre><br />
<hr /><br />
<p><img src="Files/2_9.png" alt="2 rooks placement" /></p>
<pre><code>Board:
10
10

Tree:
root
└── [1,0]
    └── [0,0]</code></pre><br />
<hr /><br />
<p><img src="Files/2_10.png" alt="2 rooks placement" /></p>
<pre><code>Board:
01
10✅

Tree:
root
└── [1,0]
    └── [0,1]✅</code></pre><br />
<hr /><br />
<p><img src="Files/2_11.png" alt="2 rooks placement" /></p>
<pre><code>Board:
00
11

Tree:
root
└── [1,0]
    └── [1,1]</code></pre><br />
<hr /><br />
<p><img src="Files/2_12.png" alt="2 rooks placement" /></p>
<pre><code>Board:
00
00

Tree:
root</code></pre><br />
<hr /><br />
<p><img src="Files/2_13.png" alt="2 rooks placement" /></p>
<pre><code>Board:
00
01

Tree:
root
└── [1,1]</code></pre><br />
<hr /><br />
<p><img src="Files/2_14.png" alt="2 rooks placement" /></p>
<pre><code>Board:
10
01✅

Tree:
root
└── [1,1]
    └── [0,0]✅</code></pre><br />
<hr /><br />
<p><img src="Files/2_15.png" alt="2 rooks placement" /></p>
<pre><code>Board:
01
01

Tree:
root
└── [1,1]
    └── [0,1]</code></pre><br />
<hr /><br />
<p><img src="Files/2_16.png" alt="2 rooks placement" /></p>
<pre><code>Board:
00
11

Tree:
root
└── [1,1]
    └── [1,0]</code></pre><br />
<p>And that's it :)<br />
We found all possible solutions, 4 solutions (with differences):</p><br />
<p><img src="Files/2_answers.png" alt="2 rooks placement" /></p>
<pre><code>10
02✅

01
20✅

20
01✅

02
10✅</code></pre><br />
<p>And if we don't distinguish between the rooks, we got only:</p><br />
<p><img src="Files/2_answers_distinguish.png" alt="answers with no distinguish" /></p>
<pre><code>10
01✅

01
10✅</code></pre><br />
<hr /><br />
<p>Okay, now it's time to visualize the decision tree for 2-rooks problem. It's important to observe the tree!</p><br />
<p>If we distinguish between rooks (which the computer always does and you need to configure it in a way that your output is filtered):<br />
• The first time we have 4 choices<br />
• The second time we have 3 choices (because we can't put one rook on top of another... haha 😋)</p><br />
<p>In total, gives use 12 different possibilities, as I explained one by one.</p><br />
<p><img src="Files/2tree_whole.png" alt="2 rooks whole tree" /></p>
<pre><code>"root"
├── [0,0]
│   ├── [0,1]
│   ├── [1,0]
│   └── [1,1]✅
├── [0,1]
│   ├── [0,0]
│   ├── [1,0]✅
│   └── [1,1]
├── [1,0]
│   ├── [0,0]
│   ├── [0,1]✅
│   └── [1,1]
└── [1,1]
    ├── [0,0]✅
    ├── [0,1]
    └── [1,0]</code></pre><br />
<p>well, well, well... </p><br />
<p>That was backtracking algorithm and detailed explanations...<br />
But,<br />
But,...<br />
A programmer needs to consider many things... They always need to write the most optimized code, what we did before was to put a rook in a specific cell, for example:</p><br />
<p><img src="Files/example0.png" alt="2 rooks placement" /></p>
<pre><code>00
01</code></pre><br />
<p>To block the second rook, only the cell below was not allowed:</p><br />
<p><img src="Files/example1.png" alt="2 rooks placement" /></p>
<pre><code>00
0X</code></pre><br />
<p>And we considered the other cells as allowed, and put a rook in them and check...</p><br />
<p><img src="Files/example2.png" alt="2 rooks placement" /></p>
<pre><code>VV
VX</code></pre><br />
<p>But is this the right thing to do?<br />
No, ofcourse not!</p><br />
<p>When we put the first rook here:</p><br />
<p><img src="Files/example0.png" alt="2 rooks placement" /></p>
<pre><code>00
01</code></pre><br />
<p>This lil-rooky can attack in its own row and column (horizontal and vertical direction) – therefore:</p><br />
<p><img src="Files/example3.png" alt="2 rooks placement" /></p>
<pre><code>VX
XX</code></pre><br />
<p>Checking the red cells (X's) is useless and pointless ^_^<br />
With these considerations, I extend and re-create the decision tree like this:</p><br />
<p><img src="Files/2tree_rewised.png" alt="2 rooks tree rewised" /></p>
<pre><code>"root"
├── [0,0]
│   └── [1,1]✅
├── [0,1]
│   └── [1,0]✅
├── [1,0]
│   └── [0,1]✅
└── [1,1]
    └── [0,0]✅</code></pre><br />
<p>Yup...<br />
It's done :)<br />
If you didn't understand, pause for a moment and try to draw the tree on paper for yourself with the new consideration (about row and column of a rook).</p>
<ul>
<li>I tell ya in secret that it seems our problem's answers for n rooks (and later n queens) are always at the n-th depth of our tree... shhhh, don't tell anyone:3</li>
</ul><br />
<p>Okay, now with this new consideration, I draw and analyze the decision tree for n = 1, 2, and 3:</p><br />
<p>For n = 1, we have:</p><br />
<p><img src="Files/1tree_whole.png" alt="2 rooks tree" /></p>
<pre><code>"root"
└── [0,0]✅</code></pre><br />
<p>For n = 2, we have:</p><br />
<p><img src="Files/2tree_rewised.png" alt="2 rooks tree rewised" /></p>
<pre><code>"root"
├── [0,0]
│   └── [1,1]✅
├── [0,1]
│   └── [1,0]✅
├── [1,0]
│   └── [0,1]✅
└── [1,1]
    └── [0,0]✅</code></pre><br />
<p>For n = 3, we have:</p><br />
<p>I'm tired from drawing so many graphical trees... Although I doubt anyone will read these!<br />
But instead, inspired by the <code>tree</code> command in Linux, I wrote a sexy function that visualizes the tree under the terminal:</p>
<pre><code>.
└── "root"
    ├── [0,0]
    │   ├── [1,1]
    │   │   └── [2,2]
    │   ├── [1,2]
    │   │   └── [2,1]
    │   ├── [2,1]
    │   │   └── [1,2]
    │   └── [2,2]
    │       └── [1,1]
    ├── [0,1]
    │   ├── [1,0]
    │   │   └── [2,2]
    │   ├── [1,2]
    │   │   └── [2,0]
    │   ├── [2,0]
    │   │   └── [1,2]
    │   └── [2,2]
    │       └── [1,0]
    ├── [0,2]
    │   ├── [1,0]
    │   │   └── [2,1]
    │   ├── [1,1]
    │   │   └── [2,0]
    │   ├── [2,0]
    │   │   └── [1,1]
    │   └── [2,1]
    │       └── [1,0]
    ├── [1,0]
    │   ├── [0,1]
    │   │   └── [2,2]
    │   ├── [0,2]
    │   │   └── [2,1]
    │   ├── [2,1]
    │   │   └── [0,2]
    │   └── [2,2]
    │       └── [0,1]
    ├── [1,1]
    │   ├── [0,0]
    │   │   └── [2,2]
    │   ├── [0,2]
    │   │   └── [2,0]
    │   ├── [2,0]
    │   │   └── [0,2]
    │   └── [2,2]
    │       └── [0,0]
    ├── [1,2]
    │   ├── [0,0]
    │   │   └── [2,1]
    │   ├── [0,1]
    │   │   └── [2,0]
    │   ├── [2,0]
    │   │   └── [0,1]
    │   └── [2,1]
    │       └── [0,0]
    ├── [2,0]
    │   ├── [0,1]
    │   │   └── [1,2]
    │   ├── [0,2]
    │   │   └── [1,1]
    │   ├── [1,1]
    │   │   └── [0,2]
    │   └── [1,2]
    │       └── [0,1]
    ├── [2,1]
    │   ├── [0,0]
    │   │   └── [1,2]
    │   ├── [0,2]
    │   │   └── [1,0]
    │   ├── [1,0]
    │   │   └── [0,2]
    │   └── [1,2]
    │       └── [0,0]
    └── [2,2]
        ├── [0,0]
        │   └── [1,1]
        ├── [0,1]
        │   └── [1,0]
        ├── [1,0]
        │   └── [0,1]
        └── [1,1]
            └── [0,0]</code></pre><br />
<hr /><br />
<p>And it's done :)<br />
By the way, before you do anything:<br />
Writing this function can be a good exercise to test your programming skills.</p><br />
<p><strong>Exercise 1:</strong> Write a function that takes a multi-dimensional array and visualizes it as a tree under terminal (like the <code>tree</code> or <code>pstree</code> commands).</p><br />
<p>Writing all the classes and functions for n_rook and n_queen took me a whole day, but writing this function to visualize the tree took me 3 days! I'm so rusy I guess... but it was challenging to write it without looking at the source code! You should try it too.</p><br />
<p>[I will send you the function I wrote at the end of the article]</p><br />
<p>Now let's move on to some important explanations:<br />
Since PHP is my favorite language, I included a PHP code that I implemented the node as a class and the tree data structure (as a class), using nodes. <br />
Oh, I forgot to mention, in computer science, a tree is a "Data Structure" like a heap or hash-table or linked-list or stack, etc. (I hope we talk about these in other articles).<br />
Then I used the tree and found all possible solutions using a extended backtracking approach and stored them in the mentioned tree.<br />
This code has an educational aspect. I wanted you to see the generated decision tree. Otherwise, if someone wants to solve this problem properly:</p>
<ul>
<li>Firstly, they probably won't use backtracking.</li>
<li>Secondly, if they do use backtracking, they definitely won't use PHP.</li>
<li>Thirdly, if they do use php, they won't store the tree in RAM at all! They can't store it! I will prove later that it's impossible! They just perform the algorithm and directly print the result in output buffer.</li>
</ul><br />
<p>When it comes to trees, all other languages step back and make way for languages like C and C++. Not because they are older and deserve respect, no :))<br />
It's because they have <code>pointers</code>...<br />
Pointers in C-like languages [including c++] are one of the major reason these languages survived so long. It's a very powerful feature... so powerful that along with being object-oriented like C++, allows you to implement your data structure in bitwise form, meaning in the peak of optimization.</p><br />
<p>I will definitely discuss pointers in detail, in a seprate article.</p><br />
<p>I did implement a tree data structure in C++ a long time ago, but unfortunately, I don't know where it is :))</p><br />
<p>Another important point I want to mention here is that with a few changes in the program for n-rook, I also implemented the n-queen problem solver... (again, I emphasize it's not an optimized implementation, it has an educational aspect). Make sure to read it.</p><br />
<p>Another important point is that with this heavy and unoptimized code, I was able to run it on my system and find the answers fo up to 6 rooks, but it crashed and froze on 7 rooks...! (Let me skip, the story is sad!!!)<br />
You might say to yourself, "Hmm :)) what's so special about 7 rooks that you couldn't handle them :))"<br />
Allow me to explain!</p><br />
<p>In 7 rooks, we have a 7x7 chessboard so (assuming I optimize backtracking by not putting next rooks in same col/row ⚠️):</p>
<ul>
<li>We can place the first rook in 49 squares</li>
<li>We can place the second rook in 36 squares</li>
<li>We can place the third rook in 25 squares</li>
<li>We can place the fourth rook in 16 squares</li>
<li>We can place the fifth rook in 9 squares</li>
<li>We can place the sixth rook in 4 squares</li>
<li>We can place the seventh rook in only one square.</li>
</ul><br />
<p>Finally, our tree has 1x4x9x16x25x36x49 leaves, which is 25401600 leaves!!!<br />
Well, that means in the seventh depth, we have exactly 25401600 nodes!<br />
Similarly, in the sixth depth, we also have 25401600 nodes (why? Think about it...)<br />
In the fifth depth, we have 1x4x9x16x25x36 leaves, which is 518400 nodes.<br />
In the fourth depth, we have 1x4x9x16x25 leaves, which is 14,400 nodes.<br />
In the third depth, we have 1x4x9x16 leaves, which is 576 nodes.<br />
In the second depth, we have 1x4x9 leaves, which is 36 nodes.<br />
In the first depth, we have 1x4 leaves, which is 4 nodes.<br />
And finally, in the zeroth depth, which is the root, we naturally have only one node.<br />
So for 7 rooks, our tree has a total of:<br />
25401600 +<br />
25401600 +<br />
518400 +<br />
14400 +<br />
576 +<br />
36 +<br />
4 +<br />
1<br />
nodes.</p><br />
<p>which is 51336617 nodes..., let's say around 50 million nodes :))</p><br />
<p>According to my calculations, in this class that I wrote, on average each empty node reserved about 80 bytes of memory from RAM. Let's assume it doesn't reserve more!! :))<br />
51336617 x 80 equals 4106929360 bytes, which is 4010673 megabytes, which is 3916 gigabytes, which is approximately 4 terabytes :)) Do you have 4 terabytes of RAM?!.. I certainly don't!</p><br />
<p>S to run this, you would need a supercomputer!<br />
And that's just the RAM usage for constructing the tree :))<br />
If you write it in optimized C++ - like really optimizing and all that stuff - and each node becomes 15 bytes... (!!!) it would still occupy 734 gigabytes of memory!!!<br />
So you have two options there:</p><br />
<ol><br />
<li>Get a hard-disk and save your tree on it... hahaha! (But then you're runtime takes years and you won't be able to run it with 8 rooks anymore!!! (Why?!) )</li><br />
<li>Skip storing the tree and just traverse and print it.</li><br />
</ol><br />
<p>In both cases, it will have a high runtime.<br />
The n-rook problem is like this because it has many solutions, while the n-queen problem has much fewer solutions, and with this code, you can even run it with tree storage. I leave it up to you.</p><br />
<p>Don't be surprised by how much resource required by the solutions is growing large...<br />
Everything grows exponentially in these scenarios. To help you understand exponential growth, I'm republishing an old story - please please please read it:3</p><br />
<hr /><br />
<p><strong>The version I heard when I was a kid:</strong></p><br />
<p>Chess is one of the oldest games in the world and has been invented many centuries ago. Therefore, it is not surprising if there are many tales about it. Here, we will mention one of them.</p><br />
<p>The tale says that chess originated from India. King Sheoram, who was fascinated by the clever moves and countless possibilities that one could make with chess pieces, became excited when he found out that its inventor was one of his people. He ordered the inventor, Sessa, to be brought to him so that he could personally reward him for this amazing invention. Sessa, the chess inventor, arrived in the presence of the king. The king kindly said, "I would like to reward you for this extraordinary invention." The scientist showed his respect, and the king continued, "I am so rich that I can fulfill your best wish. Now, tell me what you want and need."</p><br />
<p>Sessa remained silent.</p><br />
<p>The king encouraged him to speak and said, "Don't be shy, tell me whatever you want. I will not hesitate to fulfill your best wish."</p><br />
<p>He replied, "Your majesty's kindness is endless. But give me a chance to think about my request and convey it tomorrow."</p><br />
<p>The next day, Sessa surprised the king with his humble request. He said, "Your majesty! I want to have one grain of rice in the first square of the chessboard." The king, thinking he had misheard, asked, "Just a regular grain of rice?" Sessa replied, "Yes, your majesty. In the second square, two grains; in the third square, four grains; in the fourth square, eight grains; in the fifth square, sixteen grains; in the sixth square, thirty-two grains; and..."</p><br />
<p>The king angrily said, "That's enough! You will get the rice grains you wished for in the 64 squares of the chessboard. Each square will have twice the number of grains as the previous one. But know that your request is not worthy and deserving of my generosity." Then the king said, "Go! My servants will bring your sack of rice."</p><br />
<p>Sessa smiled and went to wait in front of the palace door. During lunchtime, the king remembered Sessa and asked if the inventor had received his humble reward, and they answered him, "Your majesty, Your command is obeyed. Your mathematicians are busy calculating to see how much rice he should receive." The king frowned because he was not used to such delay and procrastination in executing his orders. The night before going to bed, he asked again if Sessa's sack of rice had been given to him, but they said, "O king! Your mathematicians are always at work, and they hope to finish their calculations before sunrise."</p><br />
<p>The king angrily said, "Why are they calculating so much? The reward for Sessa should be given to him until the last grain of rice. I will not give any more orders about this!" In the morning, they informed the king that the head mathematician of the palace had requested an visit. The king accepted him. Before the mathematician could speak, the king said, "I want to know if the humble reward that Sessa requested has been given to him." The old mathematician replied, "The reason I came so early in the morning is this. We have tried our best to calculate Sessa's rice, and the amount is very astonishing." The king interrupted his speech with impatience and said, "However astonishing it may be, my royal granaries can handle it. The reward promised to him must be delivered!"</p><br />
<p>The mathematician said, "Satisfaction and fulfilling Sessa's wish is beyond your power. In all your royal granaries, there is not enough rice for the amount Sessa requested. In fact, the world has never seen such an amount of rice. If you want to keep your promise, you must order all the lands of the world to be turned into rice farms, all the seas and oceans to dry up, and all the ice and snow in distant poles to melt. And then, if all these vast lands and territories are cultivated with rice, it might be possible to give Sessa the amount of wheat he requested as a reward."</p><br />
<p>The king, who was listening attentively to the mathematician's words, thought for a moment and said thoughtfully, "What is that big number?"</p><br />
<p>The mathematician replied, "The number is 18,446,744,073,709,551,615."</p><br />
<p>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</p><br />
<p>This number is calculated by getting the sum of the following numbers, which form a geometric progression:<br />
2^64, 2^63, 2^62, ..., 2^2, 2^1, 2^0</p><br />
<p>Using the formula for the sum of a geometric progression, we get:</p><br />
<p>(2^64-1)/(2-1) = 18446744073709551615 </p><br />
<p>With calculations, it is estimated that an average cubic meter of rice contains 15,000,000 rice grains. Therefore, the reward requested by the chess inventor would require a storage facility of 1,200,000,000 cubic meters or 1,200 kilometers. If we choose a storage facility with a height of 4 meters and a width of 10 meters, it would be 30,000,000 kilometers long or eighty times the distance from Earth to the Moon.</p><br />
<p>This tale has been mentioned in various sources, and I cannot make sure which one is the original source. If you know, please let me know.</p><br />
<p>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</p><br />
<p>But here is another version, That I could find on web, written by David Blatner in the book "Spectrums: Our Mind-boggling Universe From Infinitesimal to Infinity" and qouted by Robert Krulwich in "npr.org".</p><br />
<p><strong>That Old Rice-Grains-On-The-Chessboard Con, With a New Twist</strong></p><br />
<p>Once upon a time, says the science writer David Blatner, there was this con man who made chessboards for high-end clients — in this case, a king.</p><br />
<p>The craftsman was good; his chessboards were better than beautiful. The king, he knew, loved chess. So he hatched a plan to trick the king into handing over an enormous fortune. His plan? He figured, "This king is not too good at math."</p><br />
<p><img src="Files/illustration-1_wide-1256a876ade6733db2595a012539482f0078cb8c-s800-c85.webp" alt="Con-man beside a chessboard" /><br />
Source: Robert Krulwich/<a href="https://www.npr.org/sections/krulwich/2012/09/15/160879929/that-old-rice-grains-on-the-chessboard-con-with-a-new-twist">NPR</a> </p><br />
<p>So when the craftsman presented his chessboard at court, he told the king,</p><br />
<p>"Your Highness, I don't want money for this. Or jewels. All I want is a little rice."</p><br />
<p>"Hmm," thought the king, who was a con man himself. "I've got rice. How much rice?"</p><br />
<p><img src="Files/king-and-chessboard-wide_custom-b8fefa048014f4511bf552542d8ac489fa121b86-s800-c85.webp" alt="King and chessboard" /><br />
Source: Robert Krulwich/<a href="https://www.npr.org/sections/krulwich/2012/09/15/160879929/that-old-rice-grains-on-the-chessboard-con-with-a-new-twist">NPR</a> </p><br />
<p>"All I want," said the craftsman, "is for you to put a single grain of rice on the first square, two grains on the second, four on the third, eight on the fourth, and so on and so on and so on, for the full 64 squares."</p><br />
<p>"I can do that," said the king, not thinking. And he ordered his granary to pay the man for the chessboard.</p><br />
<p>Well, that turned out to be more than a little difficult. The first few squares on the board cost the king one grain, then two, then four ... by the end of the first row, he was up to 128 grains.</p><br />
<p>In the second row, things got out of hand. By the 21st square he owed over a million grains; by the 41st, it was over a trillion grains of rice — more rice than he, his subjects or any king anywhere could afford.</p><br />
<p>He'd been had.</p><br />
<p>Or had he?</p><br />
<p><img src="Files/illustration-21_custom-f031416acb4976fccccd5cf7f761e38e371f4166-s800-c85.webp" alt="King and rice sack" /><br />
Source: Robert Krulwich/<a href="https://www.npr.org/sections/krulwich/2012/09/15/160879929/that-old-rice-grains-on-the-chessboard-con-with-a-new-twist">NPR</a> </p><br />
<p>He was, after all, a king. He knew a thing or two about negotiating.</p><br />
<p>"I will pay you," he told the craftsman. "But before you receive the money, just to be sure you are getting what you asked for, I'd like you to count each and every grain I give you."</p><br />
<p>"Oh, that won't be necessary," said the craftsman.</p><br />
<p>"Oh, it is necessary," said the king. "I wouldn't want to cheat you."</p><br />
<p>It takes one second to count a grain of rice. To count the number of grains he'd been promised, it would have taken the craftsman a half-trillion years, about 42 times the age of our universe, to complete his count. The king wouldn't pay till the count was done. The craftsman quickly realized the count would never be done. His con was counterconned.</p><br />
<p>The moral here? Kings may forget their math some of the time, but they rarely forget math all of the time. That's why they're kings.</p><br />
<p><img src="Files/king-chessboard-rice-wide_custom-6dd2385cb0dd0f59dec43b87ff5a71e7be95369a-s800-c85.webp" alt="King and chessboard" /><br />
Source: Robert Krulwich/<a href="https://www.npr.org/sections/krulwich/2012/09/15/160879929/that-old-rice-grains-on-the-chessboard-con-with-a-new-twist">NPR</a> </p><br />
<p>David Blatner includes this old tale — told briefly — in his new book, Spectrums: Our Mind-boggling Universe From Infinitesimal to Infinity. It's a book about scaling, variety and all the things we cannot see, hear, feel, count, intuit or understand. It's a celebration of mystery and mischief.</p><br />
<p>Source: <a href="https://www.npr.org/sections/krulwich/2012/09/15/160879929/that-old-rice-grains-on-the-chessboard-con-with-a-new-twist">https://www.npr.org/sections/krulwich/2012/09/15/160879929/that-old-rice-grains-on-the-chessboard-con-with-a-new-twist</a></p><br />
<hr /><br />
<p>Bloody hell ha?!<br />
That, was exponential growth, I shall write an article about it:3</p><br />
<p>Jokes aside, I would like to mention an important moral point about chess and its logic:<br />
Chess was invented at a time when kings were waging wars and expanding their kingdoms (like they don't do that anymore ×_×). Therefore, the logic behind it is that the power of the king and queen is higher than the others,  and the value of their lives is millions of times greater than the life of an innocent soldier... :/<br />
It's good to learn about backtracking algorithm or learning programming skill using trees, but if you believe that the no-good logic of chess applies to real life as well, and the life is nothing but a war between a few kings, where soldiers should get sacrificed in order to keep the king and queen safe from checkmate, in that case, you haven't learned anything.<br />
The value of all people is equal, and life is not a game of chess.</p><br />
<hr /><br />
<p>As I mentioned before, in the source code, I also provided a solution to the n-queens problem and wrote a function for it. The approach is exactly the same as the n-rooks problem with a little modification.<br />
Since I love you, I will give you a little explanation of the approach, to prevent leaving anything unexplained:<br />
Previously, when we wanted to solve the n-rooks problem, let's say for n=4:<br />
We would place the first rook in a square like [2,2]:</p><br />
<p><img src="Files/nqueen1.png" alt="n rooks one R placement" /></p>
<pre><code>0000
0000
00R0
0000</code></pre><br />
<p>Then in which squares would it attcak?</p><br />
<p><img src="Files/nqueen2.png" alt="n rooks one R placement" /></p>
<pre><code>00X0
00X0
XXRX
00X0</code></pre><br />
<p>In these squares that I marked in red [Xs], we couldn't place any more rooks.</p><br />
<p>It's obvious so far.</p><br />
<p>But imagine now in the same 4x4 board, we want to solve the n-queens problem:</p><br />
<p>Let's say we would place the first queen in a square like [2,2]:</p><br />
<p><img src="Files/nqueen3.png" alt="n queens one R placement" /></p>
<pre><code>0000
0000
00Q0
0000</code></pre></div><script src="https://tadavomnist.github.io/assets/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://tadavomnist.github.io/assets/js/MathJax.js" type="text/javascript"></script><script type="text/javascript">MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});</script><script>document.addEventListener("DOMContentLoaded", ev => document.body.querySelectorAll("#container > *").forEach(elm => elm.setAttribute("dir", "auto")));</script><script>const toggleButton = document.getElementById("dark-mode-toggle");const container = document.getElementById("container");const body = document.body;if (toggleButton.checked) {enableDarkMode();}toggleButton.addEventListener("click", () => {if (!toggleButton.checked) {disableDarkMode();} else {enableDarkMode();}});function enableDarkMode() {body.classList.add("dark-mode");localStorage.setItem("darkModeEnabled", true);}function disableDarkMode() {body.classList.remove("dark-mode");localStorage.removeItem("darkModeEnabled");}</script></body></html>